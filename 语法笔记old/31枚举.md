# 枚举
枚举可以定义一组有限的，固定的常量。
作为对照表使用。

例如中国的56个民族，使用`int`类型无法直接看出对应的民族是什么。
使用`string`类型，则可能填入不属于56个民族的值。

## 定义枚举
定义枚举使用关键字`enum`。
其内部全为常量，不能定义方法。所以也不能定义构造器或参与继承。
但扩展方法可以定义给枚举类型。

枚举内的常量只需声明名字，无需使用任何关键字和修饰符。
多个值之间使用逗号隔开。

## 访问枚举
枚举成员均为此枚举类型下的静态公开成员，
使用访问静态成员的方式，用类型点出来。

# 枚举的数值绑定
## 与整数相互转换
枚举是一张和数字的对照表。
可以使用强制转为整数类型。

整数类型也可以强制转换为枚举类型。
如果转换出了不在定义中的枚举类型，依然是有效的。
枚举不能完全限制他的值在自己要求的范围内。

## 枚举绑定数值
枚举成员具体转换为什么数字是可以自定义的。
使用变量赋值即可强行将一个枚举值绑定到一个数字上。

没有绑定数字的枚举按照以下原则进行推断绑定
- 如果是第一个成员，则绑定0。
- 绑定前一个成员的数值加1。

并且应当注意
- 应当为枚举留下一个绑定为0的值。以防止关键字`default`的枚举值不在定义范围内。
- 不应当出现绑定到相同数字的值。这样其中一些值无法用数字强制转换过去。

枚举成员的类型默认为`int`，使用继承的语法可以把枚举改为绑定其他类型的整数。

# 位枚举
当枚举可以组合时，可以使用位运算对枚举进行组合，拆分。
为了便于位运算，所有枚举成员都应该绑定到2的整数次幂。

为枚举类型加上`[Flags]`特性，他的`ToString`方法就会输出组成成员的列表。
枚举有一个实例方法`HasFlag`可以用于判断自己身上是否有参数进行组成。





位枚举是一种特殊的枚举，用于表示多个独立的布尔标志，可以使用位运算符进行组合或分解。
位枚举通常将每个成员的数值绑定为2的整数次幂，
这样可以保证每个成员只占用一个二进制位，并且不会与其他成员重叠。
位枚举可以使用`[Flags]`特性标记，他实例的`ToString`方法，会输出这些组成成员用逗号分隔的列表。
```csharp
[Flags]
enum Position // 职位
{
	Founder = 0b1, // 创始人
	ViceLeader = 0b10, // 副首领
	Builder = 0b100, // 建造师
	Promoter = 0b1000, // 宣传师
	Recruiter = 0b10000, // 招聘者
	Cleaner = 0b100000, // 整治者
	Researcher = 0b1000000, // 研究者
}
```
# 使用枚举
## 访问成员
要访问枚举成员，直接使用类型名访问他的成员。
```csharp
Card Card = new Card();
Card.Suit = Suit.Spade;
Card.Rank = 4;

public class Card
{
	public Suit Suit;
	public int Rank;
}
```
## 位运算
使用位枚举，可以使用位运算符进行组合或分解。
位或运算符`|`可以将多个位枚举成员合并为一个值，表示同时具有这些成员的标志。
位与运算符`&`可以将一个位枚举值与另一个值进行比较，判断是否包含某个成员的标志。
```csharp
Position CarpDragon = Position.Founder | Position.Recruiter;
// 职位 暴鲤龙 = 职位.创始人 | 职位.招聘者;
if ((CarpDragon & Position.Recruiter) == Position.Recruiter) 
{
	Console.WriteLine("成员暴鲤龙具有招聘权限");
}
else 
{
	Console.WriteLine("成员暴鲤龙禁止招聘");
}
```
实例方法`HasFlag`封装了使用位与运算符判断是否包含某个标志的逻辑，可以简化代码的编写。但是，如果枚举中存在0或其他特殊值，可能会导致意外的结果。
```csharp
Position Sunflower = Position.Founder | Position.Recruiter;
// 职位 向日葵 = 职位.创始人 | 职位.招聘者;
if (Sunflower.HasFlag(Position.Recruiter)) 
{
	Console.WriteLine("成员向日葵具有招聘权限");
}
else 
{
	Console.WriteLine("成员向日葵禁止招聘");
}

```
## 数字转换
要将枚举值和数字值进行转换，可以使用强制类型转换。强制类型转换可以将一个枚举值转换为其对应的数值类型，或者将一个数值类型转换为其对应的枚举值。
枚举值和数字值之间可以进行算术运算，例如加减法。
但是，这可能会导致超出枚举定义范围的结果，或者破坏枚举的语义。
```csharp
Weekday weekday = (Weekday)7; 
Console.WriteLine((int)weekday > 3); 
Console.WriteLine(weekday - 3); 
```



