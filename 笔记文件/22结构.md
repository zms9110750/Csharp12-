# 结构
## 定义结构
结构是c#中一种基本的值类型。
其定义语法和类相似，只是关键字换成`struct`。

## 结构记录
结构也可以在前面加上`record`修饰，成为值类型的记录。
和普通记录一样，会根据主构造器参数自动合成
- `{get; init;}`属性
- 转为文字方法。
- 解构方法。
- 比较方法。

# 结构和类的区别
## 结构是值类型
结构是值类型，存放的数据就是自己定义的所有字段。
在赋值时，会复制所有的字段依次赋值。

因为本体就是自己声明的那一堆成员。
所以赋值这个复制的过程也是复制那一堆成员。
完成赋值后两个变量就互不影响。

## 不能嵌套自己
类的变量只是一个指针数据。基本上就是一种数字类型。

但结构的内存占用为字段加起来。如果字段有结构的话则要进行加总。
如果结构字段包含自己，就会产生无限递归。
## 只读
结构设置为只读后，其内容就不能再改变。
因为所有内容都属于这种类型的变量的一部分。

## 不能改变方法返回的结构
只有变量才能赋值。而方法（和属性）返回来的值不是变量。
类是因为指针能窜号，在一个地方改了，另一个地方也可以看到。

而结构不会窜号，这样的更改没有谁能读取，更改不起作用。
必须先用变量保存，才能更改。

## 可以使用`with`克隆
因为结构自己的赋值就是把所有内容复制。
所以结构无论是不是记录，都可以使用`with`进行克隆。

## 相等判断
结构的`Equals`会自动判断里面的所有字段是否相同，和元组类似。
但结构没有默认的`==`运算符。必须自己定义。

## 必须有公开无参构造器
结构必须有一个公开的无参构造器。
即便自己设置了构造器，编译器自己合成的无参构造器也不会消失。
即便定义了主构造器，这个无参构造器也依然存在。

而如果自己定义了无参构造器，那会要求你必须是公开的。

## 构造器必须经过主构造器或无参构造器
在结构内定义普通构造器时，必须使用构造器链调用主构造器。

没有定义主构造器时，则要通过构造器链调用无参构造器。

## 不能给字段设置初始值
结构使用`default`获得的值是结构内所有值为`default`的情况。

如果给字段设置初始值，则必须要定义一个构造器。
编译器会自动把这些赋值合成到编译器的开头。
初始值不会影响到`default`的结果。

自动合成的赋值只影响你自己定义的构造器。
如果无参构造器是编译器合成的，那么他依然不会经过初始值赋值。

# 大型结构性能优化
## 防御性副本
由于结构是整体复制的。大型结构在作为方法参数时，这个复制过程可能消耗大量资源。
并且又不希望修改内部的值，此时可以使用`in`引用参数来获得这个结构。

但这个时候还不够，如果调用了里面的任意方法，则仍有可能修改这个结构。
此时，即便使用引用参数，也会创建一个复制品，改为对他调用方法。

## 只读方法
在方法（包括属性，索引器，事件）前面使用`readonly`进行修饰。
则在上述情景中调用`readonly`方法不会再创建防御性副本。

而被`readonly`方法修饰的方法或访问器，
在主体内会视作所有字段都有`readonly`一样，不能修改。

## 只读结构
上述情况还有一个问题。
在`readonly`方法内如果调用没有`readonly`修饰的方法，仍然会创建防御性副本。

可以一不做二不休，把整个结构设置为只读的。这种情况下，所有字段必须设置为只读的。
而所有自动属性不能有`set`访问器。

这种情况下所有的方法则视为是只读的。
# 引用结构
在结构前加上`ref`，则内部可以声明`ref`字段。

引用结构因为包含了`ref`字段，
他自己的生命周期不能触碰到原本引用变量碰不到的地方。
否则会带着指针逃逸。

- 它只能作为局部变量或其他引用结构的字段
- 它不能实现接口，因为转换为接口会导致装箱。
- 它不能赋值给ValueType或object类型，也不能调用它们的继承来的方法（包括ToString）
- 不能声明引用结构的数组。
- 它不能作为泛型的类型参数
- 它不能被匿名方法或局部方法捕获
- 它不能出现在迭代器或异步方法中