# 记录
## 声明记录类型
记录是一个类型，声明记录的方式类似于方法，但是要求
- 所有的类型声明都必须在顶级语句之下。
- 使用`record`关键字代替方法的返回类型
- 主体里的声明只能有声明语句，即声明变量或方法。
- 执行语句可以用来给变量赋值或者存在于方法里面。
- 声明的方法或变量，名字不能和这个记录自己相同。

## 使用记录类型
记录类型的变量的值，声明方式和调用方法类似，但是要在前面加个`new`。
类似于`new Student("小明", 12)`

这样的记录可以访问他的属性。但只是这样的话，作用也就跟个元组一样。
甚至记录的属性不能改写,还不如元组。

# 成员
直属于一个类型中的东西称为这个类型的成员。
例如记录里声明的变量叫成员变量。方法叫成员方法。
而方法里声明的叫局部，例如局部变量，局部方法。

类成员除了变量和方法以外还可以声明`索引器`，`属性`，`事件`，和类型声明。
索引器，属性，事件，类型不存在与之对应的局部声明。
类型声明可以直接声明在最外层，也可以嵌套在一个类型中。
最外层的叫顶级类(型)。嵌套的叫成员类，无论经过几层嵌套。

## 字段
成员变量称为`字段`。和变量区别开的原因是，变量在方法结束时就会被清除。
但字段是直属于类的。只要还会用到这个类，就有可能用到这个字段。
所以字段不能随便清除，只能等到确定这个类完全不用以后才会跟着这个类一起被清除。

### 只读字段
在字段的前面使用`readonly`修饰，可以让这个字段在完成构造过程后不能再更改。
只有字段能用它修饰，局部变量不行。

## 属性
属性是命令，类似方法，是需要执行的东西。
属性的声明语法和方法，变量都不同。
但调用者使用的访问属性的语法和直接访问变量一样。

这就是属性的理念：虽然他会执行一些东西，但看起来和访问变量一样。
访问字段是不会出现错误的，所以访问属性也不应该出现错误。
访问字段是不会修改类里面的东西的，所以多次访问字段应该得到一样的结果。

### 自动属性
一个最简单的属性声明是把变量后面的`;`改为`{get; set;}`
他就变成一个属性了，并且不附带任何逻辑，作用非常类似字段。

在c#的设计理念里，字段是不能给外部直接访问的。
所以完全像字段一样，不带有任何逻辑的属性，也要作为属性写出来。

### 有逻辑的属性
一个完整属性的类似这样：`string Age { get => age; set => age = value; }`
其中，`age`是另外一个单独的字段。
通常一个属性只管理一个字段，并且会把属性的名字看起来和他管理的字段有关系。

### 复杂逻辑的访问器
属性当中的`=>`是表是一个方法只有一条语句。
普通的方法如果只有一条语句也可以这样写，例如`void Show() => Console.WriteLine(Name);`

如果属性当中的访问器所需要的逻辑，不能用一条语句表示，那么可以改为大括号包围。
其中，`get`访问器类似于一个返回属性类型的方法。
`set`访问器是有一个参数的，无返回值的方法。
参数名为`value`，值为给这个属性赋值时用的值，类型是属性自己的类型。

### 只读属性
属性的`get;`表示可以读取以及如何读取。如果删去就不能读取。
`set`表示可以赋值和如何赋值。删去就不能赋值。
但一个属性里至少存在一个访问器，不能两个都删了。

一个属性通常是可读写的或者只读的。只写的属性不符合设计理念，因为他改变了类里的字段。
对于一个只读属性，若其的逻辑是使用了`=>`的单挑语句，
那么可以省略属性的大括号和`get`，简写为这种形式：
`int Rand => Random.Shared.Next(6);`

### 仅初始化属性
将`set`访问器替换为`init`访问器。
那么这个属性将类似于只读字段，只能在构造过程中对其赋值。之后不能再对他赋值。

### 自动属性的初始值
一个有逻辑的属性，他控制的字段是你自己声明的。
如果要赋值初始值，直接对他操作就行了。

但没有逻辑的属性，他控制的值是编译器自己加的，你访问不到。
此时如果要给他赋值初始值，就需要直接对这个属性进行赋值。
类似于这样的形式：`string Name { get; } = "小明";`

## 索引器
索引器的理念类似于属性。
不同的是，他的名字限定为`this`，后面需要用`[]`写至少一个参数。
类似这样：`int this[int index] { get => arr[index]; set => arr[index] = value; }`

索引器的理念类似于数组。一般也是用来控制数组之类的东西。
在他的`get`和`set`中都能访问到`[]`内定义的参数。
调用索引器的语法也类似于数组索引。
## 方法
成员方法是可以同名的，但他们的参数列表不能相同。这种情况下称为`重载`。
参数列表是指参数的：数量，种类，顺序。
并且引用参数和普通参数视为不同的类型，
但三种引用方式(`ref`,`in`,`out`)视为相同类型。

## 事件
事件类似于属性，但是给`委托`专用的。在委托章节讨论。


# 生命周期
## 分配内存
当一个`new`运算符执行时，他会检测右边的类型，
查找类型的完全声明，计算他所有字段占用的内存。
（只有字段占内存。方法是同一类型下所有值共用的，不单独储存）
然后找一块合适内存划分给他。

## 构造器
在`new`后面跟随的方法，就是这个类型的构造器。
构造器通常用于给字段设置初始值。
这个阶段可以给只读字段赋值，和使用`init`访问器。

构造器执行先于内部所有方法，必定执行且只执行一次。

### 主构造器
在类型后面的括号里声明参数即为主构造器。

记录的主构造器会自动生成同名的`{get;init;}`属性，
除非自己声明了同名的字段或属性。

主构造器里的参数还可以用来作为初始值使用，或参与运算初始值的表达式。

主构造器里的参数也可以被属性或方法使用，但这样做，编译器会把他作为字段捕获。
之后你甚至可以在方法里对这些参数进行修改。因为实际上他们已经是字段了。
### 普通构造器
普通构造器的声明方式为`类型名+参数+主体`。
构造器和方法区别开来就是因为构造器是不写返回类型的。

一个类型可以不声明主构造器（也可以不声明主体，改为以分号结尾）。
没有主构造器也没有普通构造器的类型，编译器会自动合成一个无参的构造器。

### 构造器链
如果一个类型具有主构造器，那么必须经过主构造器。
普通构造器调用其他构造器的语法为，在参数列表后面,方法主体前面，
追加`:this(参数)`以对其他构造器进行调用。

这种特殊的语法表示，调用其他构造器只能调用一次，且在开头调用。
以此法进行调用的构造器可以不是主构造器，而是另一个普通构造器。
但有主构造器的类型，构造器的链式调用必定溯源到主构造器。

## 对象初始化器
在构造器后可以以大括号对里面的其他部分进行赋值。
其效果类似于执行完构造器后依次手动赋值。
这样写以强调这些内容都是进行初始化过程。
此外，这个过程可以对`init`访问器的属性进行赋值（但不能给`readonly`字段进行赋值）。

### 克隆和修改
在后面追加`with`和对象初始化器，会改为进行构造一个新的记录。
新的记录会访问其主构造器里所有内容。然后以这些值作为参数调用记录的主构造器。

之后的初始化器则是在这个构造器新构造的记录进行赋值。
## 被清理
在内存使用到一定程度时，.Net会执行垃圾清理。
如果清理完后内存依然不足会申请占用更多内存。

所以，一个记录从不使用到被清理是有时间差的，不是立刻的。
在被清理时，会执行他的终结器。

终结器的声明方式是在无参构造器前加一个`~`。
因为这是由系统调用，所以你没有机会给他传递参数，只能是无参的。
`~`在c#中有相反的意思，表示和构造相反的过程，即终结。