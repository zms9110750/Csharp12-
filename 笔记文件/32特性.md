# 自定义特性
## 定义特性
特性是一种继承自`Attribute`类的类，它可以具有类的所有功能。
但标记特性时只能用常量为参数赋值。获取特性时需要的值通常也只有这些参数。
所以额外的字段和方法通常也不会使用。

## 限制特性

在特性类上添加`AttributeUsage`特性可以限制此特性所处的位置。
例如类，字段，属性，方法，事件，方法参数等等。
他的参数`AttributeTargets`枚举是一个位枚举。
可以通过组合来复合出需要的位置。
# 添加特性 
在一个类成员，类型，方法参数前，
可以使用方括号声明一个特性类。

特性类应当使用`Attribute`结尾以表明这是一个特性。
而在添加特性时可以省略这个后缀。
如果不是以`Attribute`为后缀，
则可以在特性类名前加`@`表示就是写出来的名字。

多个特性可以在一个方括号内用逗号隔开，
也可以写多个方括号。

## 特性的构造器
作为特性标记时，特性类有独特的构造器语法。

- 不需要添加`new`。
- 如果使用的是无参构造器，可以省略方法的括号。
- 在构造器参数传递完后，还能在构造器里以对象初始化器的语法传递参数。
- 参数只能是常量，不能调用方法。

# 访问特性
在源码中，编译器的分析器可以观察到这些特性并做出相应的行为。
例如弹出警告和错误。此类特性例如`Obsolete`特性，
其用来标识过时的方法/类型。 


在运行中的代码，可以使用反射检查自己身上的特性，
`Flag`特性改变枚举的输出就是这个原理。

# 反射
## 获取类型信息
使用反射首先要得到一个类型的元数据

有三种方式
- 任何实例可以通过`GetType()`方法获取元数据
- 使用`typeof()`表达式写死获取一个类型的元数据
- 使用`Type.GetType()`方法，传入类型的完全限定名。他会从程序集里加载类型元数据。

## 获取成员
获取到元数据后，可以继续获取他的成员字段，属性，方法等等元数据。
以此法可以获取到匿名字段。

获取成员的方法通常可以传入一个`System.Reflection.BindingFlags`类型的枚举。
如果不传入，默认按照公共实例的过滤条件筛选。
如果自己传入，这是一个位枚举，可以自由复合。
但如果不想进行过滤，可以使用`(System.Reflection.BindingFlags)(-1)`快速构建一个包含所有位的枚举。

## 获取元数据
使用反射获取到一个类型/成员的数据后可以用属性查看他们的一些元数据。
例如是否是`public`，是否是`static`，是否是`abstract`的。
特性也属于这种元数据。
通过`CustomAttributeExtensions.GetCustomAttribute`（扩展方法）方法可以查询指定类型的特性。
例如：`t.GetCustomAttribute(typeof(ObsoleteAttribute))`。

以此法获取的特性实例是使用其标记的特性构造器生成的。
也就是说如果特性里字段的初始值使用了随机数生成，
那么多次获取特性得到的字段是不一样的。



