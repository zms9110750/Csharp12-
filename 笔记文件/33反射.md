# 反射
## 获取类型信息
使用反射首先要得到一个类型的元数据

有三种方式
- 任何实例可以通过`GetType()`方法获取元数据
- 使用`typeof()`表达式写死获取一个类型的元数据
- 使用`Type.GetType()`方法，传入类型的完全限定名。他会从程序集里加载类型元数据。

## 获取成员
获取到元数据后，可以继续获取他的成员字段，属性，方法等等元数据。
以此法可以获取到匿名字段。

获取成员的方法通常可以传入一个`System.Reflection.BindingFlags`类型的枚举。
如果不传入，默认按照公共实例的过滤条件筛选。
如果自己传入，这是一个位枚举，可以自由复合。
但如果不想进行过滤，可以使用`(System.Reflection.BindingFlags)(-1)`快速构建一个包含所有位的枚举。

## 获取元数据
使用反射获取到一个类型/成员的数据后可以用属性查看他们的一些元数据。
例如是否是`public`，是否是`static`，是否是`abstract`的。
特性也属于这种元数据。
获取特性是根据特性上的构造器构造一个新的特性，
如果特性里有随机数这类的东西，多次获取会得到不同的值。


## 调用方法
方法，属性，索引，事件上获取的访问器，
都可以获得这个方法的委托，并且可以执行他。

## 修改字段
字段和属性有对应的修改和获取字段的方法。
如果可以的话（不能是`readonly`，或者存在对应的访问器）。

# 反射的缺陷
反射是很消耗资源的，由于源码中不能判断类型，
于是反射的相关API全部使用`object`类型。
但是实际执行的时候对他有类型要求，全部都要进行类型判断。

替代方案是使用源生成器，这是一种编写分析器的方式。
反射过程会在编写源码时完成，并生成对应的代码。

或者使用表达式树，表达式树的构造一般也要使用反射。
然后可以编译成委托，执行委托会省略中间每处API调用都判断类型的过程。
