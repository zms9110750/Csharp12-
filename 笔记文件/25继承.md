# 继承
类可以选择继承另一个类。
不过普通类只能继承普通类，
记录类只能继承记录类。

结构不能继承。
## 定义
继承的语法是在类名后面使用`:`衔接要继承的类型。
如果自己使用了主构造器，那么`:`后面的类型也要调用他的一个构造器。
(除非有可访问的无参构造器，这样会自动调用)

编译器要从继承链中检查所有的类型。所以基类的访问权限不能低于自己。
例如自己是一个`public`的，而选择继承的是自己身上的私有的嵌套类。

继承或获得其实例成员，因此没有实例概念的静态类不能参与继承。

## 获得继承的类成员
在定义继承类型后，有以下作用

- 获得他的实例成员，除了构造器和终结器。
获得是指在`new`的过程中，会检查并记录这些成员。
不代表你可以访问他们。

- 可以访问他的`protected`成员。但私有成员仍然不能访问。

## 访问基类成员

使用`base.`可以强制访问基类成员。
在自己身上定义了和基类同名的成员时，
以及需要访问基类构造器时可以使用。

编译器会自动让你的构造器以构造器链调用基类的无参构造器。
如果基类没有，或是不具有访问权限，
则必须自己声明一个构造器并主动调用基类的一个构造器。

## 覆写
派生类可以定义和基类同名的成员。
此时基类会隐藏派生类的同名成员。

这是默认行为，编译器会警告你添加`new`进行修饰。
这只是醒目表示基类有一个同名成员且被隐藏了。没有实际作用。

# 虚方法
使用`virtual`修饰符修饰一个方法（属性，索引器，事件），
可以在子类中对其进行重写。

## 重写
使用`override`修饰一个和基类同名同参数同返回值的方法，
可以重写基类的成员。

重写后，任何调用基类的这个方法，都会转为调用你重写后的方法。
哪怕是在基类的构造器中调用这个方法。
（从你的构造器通过构造器链调用基类构造器的时候）

# 密封
一个虚方法重写后，仍然是一个虚方法，还能再被派生类继续重写。
如果想改变此行为，可以使用`sealed`修饰这个方法。

## 密封类
使用`sealed`修饰一个类，可以阻止有其他类从他身上再进行继承。

# 抽象类
在类前面加`abstract`可以把类声明为抽象类。
这个类的构造器只能给派生类调用。不能和`new`搭配使用。

## 抽象方法
抽象类的意义是可以存在抽象方法。
抽象方法（属性，索引器，事件）是使用`abstract`修饰的方法。
这是一种没有主体的虚方法。

因为没有主体逻辑，所以不能构造一个抽象类的实例，
否则调用他的方法的时候，没有逻辑可以执行。

抽象方法只能存在于抽象类中。所以如果有不是抽象的类继承了抽象类，
那就必须重写所有抽象方法，使这个实例的所有方法是有主体逻辑的。

虚方法可以重写也可以不重写。
意味着虚方法的主体是作为默认逻辑补充的。
那么抽象方法就是无法预测默认行为。
必须具体到子类才能决定自己的方法该做什么。

# 多态
## 可为基类赋值
一个派生类型的实例，可以赋值给基类的变量。
`普通人 pop=new 研究员();`。
因为继承获得了基类的所有成员，并且重写时不能降低访问权限。
所以基类能干的事，派生类都能干。也就是说可以把派生类当作基类使用。

这个用法主要是在声明方法参数时。
`void Show(普通人 student)`，`Show(pop)`
如果方法里只是要人去搬砖，不需要用到研究员特有的方法。
那就没有必要要求参数类型是研究员。
写能满足自己要求的最基类型的类型就行了。

## 对象头
在`new`构造一个实例的过程中，
首先会分析这个类的基类，再看基类有没有基类。
找齐继承链上所有类型后，再分析他们的字段。

实例分配的内存是他的字段，和他的对象头。
对象头有两个指针，一个是同步块，用于多线程时上锁用。
另一个是自己的元数据，储存了这个类型有什么成员。

值类型在没有装箱时没有对象头。

## 调用方法指令

在一般情况下，要调用一个引用类型实例的方法，首先要获取该实例的对象头，
从对象头中读取元数据，然后根据元数据中的方法表找到对应的方法地址。然后调用该方法。

对于普通方法，编译器会直接将方法地址嵌入到代码中，省略查找对象头的步骤。
因为编译器在编译时是看着类的定义编译的，知道要调用的方法在什么位置。

但是虚方法不同。虚方法的基类实现和派生类实现都可能被调用。
而调用哪一个实现取决于实例的实际类型。必须去经历查表过程。

但是在密封虚方法后，它就变成了一个普通方法，编译器就可以对它进行优化了。

# object
`object`是安全代码下所有实例的基类。
在你使用`class`关键字声明类型时，他就继承自`object`了，哪怕是静态类。
在你使用`struct`关键字声明结构时，他继承自`ValueType`。
而`ValueType`当然也是继承`object`的。

## ToString
这个虚方法决定了一个实例如何转为字符串。可以重写。

默认实现是调用自己的`GetType`并输出他的`ToString`。

## GetHashCode
这个虚方法决定了一个实例如何转为数字。可以重写。

重写时，设计理念要求这个数字的构成使用了所有字段参与。
保证在有任何一个字段不同的情况下，以此法获取的数字大概率不同。

默认实现是使用c#自己的方式用所有字段计算出一个值。

## GetType
从对象头获取元数据。

## Equals
这个虚方法决定了如何判断另一个实例是否和自己相等。
默认实现是调用`ReferenceEquals`方法。
但`ValueType`重写了，改为判断结构内所有字段是否相等。
所以你定义的结构类型都能自动判断内容。

## ReferenceEquals
静态方法，用于判断两个指针是否一样。

## MemberwiseClone
`protected`的克隆方法。直接从内存中复制一份，
以生成自己类型的复制。
