# 异常
一个方法的执行应该是在一定的条件下才能顺利执行。
并且我们期望方法的执行是符合我们的期望的。

但如果你给的东西不能让方法顺利执行，
尽管他可以继续执行下去，但结果很可能是非预期的。
此时没有必要把方法继续执行下去了。
## 抛出异常
在方法内使用`throw`关键字，后面跟随一个异常类实例，可以抛出这个异常实例。
抛出异常时，方法会终止，并传递给调用者。
直到异常被处理，或者一直上抛直到程序的启动方法，导致程序中止。

## 自定义异常类
异常类是指`Exception`类型，当然也包括他的所有派生类。
如果我们想要自定义异常类，只需要继承这个类就行。

异常类可以当作普通数据类型使用，只有在被抛出时，
他才会发挥他作为异常类型的作用。

异常类的主要职责是描述这个异常，
他应当包含一个传入字符串的构造器，并且调用`Exception`的传入字符串的构造器。

# 异常处理
使用`try{}catch{}`块包围代码，
在`try`块中如果出现异常，那么这个`try`块会终止，
转而执行`catch`中的内容。

## 分类捕获
在`catch`块后，可以使用小括号声明一种异常类型。
然后他会像`if-else if`一样逐层判断类型，
直到找到一个类型匹配的`catch`块。

类似`if-else if`，如果运行了一个块，
之后的块就不会再运行和判断了。
或者如果全都没匹配到，则一个块都不会执行，异常会继续上抛。

不带有类型判断的`catch`等同于捕获`Exception`类型类型。
像无条件的`else`一样，他必定捕获成功，后面不能再跟随`catch`块。

## 捕获异常
在`catch`声明类型时，可以声明一个变量。
类似于模式匹配，条件满足时，这个变量会被赋值为捕获的异常。
然后你可以对他的内容进行访问。

一些情况下，异常捕获仅记录下当前异常信息，
然后继续上抛异常。
在`catch`块中使用`throw`可以不跟随一个异常实例。
这样的话会认为你要抛出的是这次捕获到的异常。

## 条件捕获
在`catch`声明异常类型后，可以加`when()`来进行一个条件判断。
类似于在`switch`中，使用`when`进行一次次要判断。

# 最终执行
`catch`块后还能跟随`finally`块，
也可以在没有`catch`的情况下直接尾随`try`块。
无论`try`有没有成功执行完毕，无论执行的是哪一个`catch`,
`finally`都会执行。

并且如果上述块中含有`return`语句结束方法，
也会先执行`finally`才结束方法。

## 非托管资源
.Net帮你管理的资源叫托管资源。
不由他管理的叫非托管资源，
例如你的代码中打开了网络连接，这个过程要操作系统调用网络端口。

`finally`块通常就是用来关闭这些资源的。
无论方法执行是否成功，抛出的是哪一个异常，都要关闭外部资源。

如果代码里没有关闭，通常情况下操作系统会在程序结束时清楚他占用的资源。
但如果关闭有先后顺序要求，那么操作系统可能也无法成功关闭。

## using 语句
一些类型实现了`IDisposable`接口，表示可释放。
在声明变量时，可以在类型前加上`using`。

编译器会把他所处的作用域编译为`try-finally`块，
并在`finally`中调用这个接口的释放方法。
