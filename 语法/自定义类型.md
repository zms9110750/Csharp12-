# 自定义类型


c#中的自定义类型有

- 结构
- 类
- 接口
- 委托
- 枚举

其中，类和结构的声明类似于方法声明。  
只是把返回值替换为关键字。但类主体可以写的东西和方法有所差别。  
并且，参数和主体为空的情况下，可以省略不写以分号结尾。

```csharp
record MyRecord1;
record MyRecord2();
record MyRecord3 { }
```

**顶级语句必须位于所有类型声明之上**。

## 类

以类似方法声明，但把返回值改为`class`关键字的方式可以声明类。

```csharp
class MyClass()
{
}
```

`class`在c#中是引用类型，类似于其他语言中的指针。  
直接赋值传递给其他变量时会传递这个指针。  
导致不同变量访问和修改到相同的数据。

适用于长期存在的数据，传递引用会忽略复制内容导致的开销。  
或需要在很多地方进行交互的数据。以共享数据修改。

## 结构

类似方法声明，但把返回值改为`struct`可以声明结构。

```csharp
struct MyStruct
{
}
```

`struct`在c#中是值类型，变量自己存放值的内容。  
赋值给其他变量后，两个变量的访问和修改互不干涉。

适用于只被一个值掌握的数据，例如坐标只被一个单位使用。  
以及存放数组中或临时使用时，具有比`class`更好的性能。[^更好性能]

[^更好性能]:
在数组中，当一个值被使用时，载入cpu缓存时可能把附近的值一起载入。  
这让批量使用的时候剩下来一点从内存载入数据的时间。  
而`class`即便被一起载入，也要根据指针查找内存。  
在临时使用时，`class`在c#源码中都以指针形式存在，   
实际内容由.Net管理。但.Net不能立刻知道不会再使用了。  
所以对内存占用的清理也会延后到统一内存清理的时候。

### 只读结构

结构前可以使用`readonly`修饰。  
这会要求所有字段都是`readonly`的。

大型结构复制有开销，因此可能选择使用引用传递。  
使用`in`传入方法后，虽然不能修改内容变量，但仍然可以调用方法。  
而结构自己的方法里可能会修改变量。

如果真的调用了这样的方法，那么结构仍然会复制一份。  
只读结构仅用来防止这种情况。

### 引用结构

在结构前加上`ref`修饰，  
成员可以存在引用变量或引用结构。

引用结构只允许出现在其他引用结构中，  
或在方法中被临时使用。[^引用结构]

```csharp
ref struct RefStruct(ref int int32)
{
	ref int i = ref int32;
}
```

[^引用结构]:不能创建数组，不能作为泛型类型，不能被方法捕获。

## 记录

可以使用`record`关键字修饰`class`和`sturt`。  

- `record class`可以省略`class`。`readonly record sturt`的只读和记录的位置不能更改。
- 储存参数，可以被外部访问
    - `record sturt`的参数可以读写。  
	- `record class`和`readonly record struct`是只读的。
- 改变转文字的默认逻辑。除了类名以外还输出参数名和参数的字符串。
- 可以像元组一样解构。

```csharp
Point point = new Point(20, 30);
Console.WriteLine(point);//Point { X = 20, Y = 30 }
int x = point.X;
int y = point.Y;
(x, y) = point;//像元组一样解构

record struct Point(int X, int Y);
```

## 对象初始化器

在创建一个对象后对他的成员进行赋值，可以用对象初始化器语法。

- 除了可以为`init`访问器的属性赋值外，与直接赋值没有区别。
- 对象初始化器的执行顺序和自己赋值一样，晚于所有初始化过程。
- 对象初始化器中可以为集合的部分元素初始化。

```csharp
Point2 point = new Point2(2, 2, new int[10]) { X = 20, Y = 30, Arr = { [0] = 1 } };

record struct Point2(int X, int Y, int[] Arr);
```

### with

`record`,`struct`可以使用`with`表达式创建一份复制。  
可以像对象初始化器一样改写部分值。其余值于被复制的值一样。

```csharp
var point2 = point with { X = 30 };//Y的值会复制point.Y
```

## 嵌套类

类，结构，接口中能嵌套定义自定义类型。  
这种类型称为嵌套类。除此之外的类型称为顶级类。

如果想访问嵌套类，需要从定义类中用`.`访问。

```csharp
Rec2.Rec3 rec = new Rec2.Rec3();//不可访问，有保护级别

record Rec2
{
	record Rec3;
} 
```

## 访问权限

一般来说，声明的东西只能在所处的大括号及内部才能访问。  
但作为类成员时，可以在大括号之外访问。

但必须对外公开访问权限。

```csharp
Rec2.Rec3 rec = new Rec2.Rec3();//可以访问

record Rec2
{
	public record Rec3;
}
```

访问权限有以下修饰符：

1. `public`（公开）：任何地方都能访问
    - 接口的实例成员默认为此权限
2. `protected  internal`：本程序集的类或派生自该类的类
2. `protected`（保护）：派生自该类的类
2. `internal`(内部)：本程序集[^别人不能用]
    - 顶级类定义默认为此权限
    - 程序集在解决方案里是一个**项目**。
2. `private protected`：本程序集里且派生自该类的类
2. `private`（私有）：仅限所属大括号内  
    - 类成员默认为此权限
2. `file`:只允许在当前文件访问
   - 一般用于自动生成的代码
   - 只允许用于顶级类

[^别人不能用]:这个范围是为**我能用，而别人不能用**的范围。  
一般自己的项目给别人用是打包好的程序集。  
这个权限要求掌握源码的人才能访问。