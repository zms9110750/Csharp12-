# 选择

## if

`if`选择可以判断一个条件。只有条件满足(为`true`)，他跟随的语句块才会执行。

```csharp
var r1 = Random.Shared.Next(10);
Console.WriteLine("随机数是" + r1);
if (r1 < 5)
{
 Console.WriteLine("随机数小于5");
}
```

### else

`if`语句块之后，可以续接任意数量的`else if`语句块。
当前者的条件不满足时，会顺延到下一个`else if`继续进行判断。

如果有`else if`满足条件就会执行他的语句块，不会再继续顺延。

最后一个`else`可以不跟随`if`和条件。那么顺延到这个`else`的时候不会再判断条件，必定执行此处的语句块。

```csharp
int r2 = Random.Shared.Next(100);
if (r2 > 98)
{
 Console.WriteLine("评分为SS");
}
else if (r2 > 95)
{
 Console.WriteLine("评分为S");
}
else if (r2 > 90)
{
 Console.WriteLine("评分为A");
}
else if (r2 > 80)
{
 Console.WriteLine("评分为B");
}
else if (r2 > 60)
{
 Console.WriteLine("评分为C");
}
else
{
 Console.WriteLine("未通过");
}

```

## switch

对于常量判断的多个`if-else`，可以使用`switch`语法进行判断。
其作用和`if-else`相同，仅是在语法上强调此处的并列关系。

```csharp
var r3 = Random.Shared.Next(12) + 1;
switch (r3)
{
 case 1:
 case 3:
 case 5:
 case 7:
 case 8:
 case 10:
 case 12:
  Console.WriteLine(r3 + "月有31天");
  break;
 case 4:
 case 6:
 case 9:
 case 11:
  Console.WriteLine(r3 + "月有30天");
  break;
 case 2:
  Console.WriteLine(r3 + "月有28天");
  break;
 default:
  Console.WriteLine("无效的月份"); 
  break;
}
```

每个`case`分支后跟随的必须是常量。
当被判断的变量和此常量匹配时，就会进入此分支里的语句。
如果此分支下没有任何语句，则顺延进入到下一个分支，直到有语句。

如果所有的`case`均不匹配，则会进入到`default`分支。
`default`分支是可选的，如果不存在且其他所有`case`均不匹配，则不会执行这个`switch`里的任何语句。
`default`分支的顺序可以是任意的。即便它写在中间，也会跳过它先判断之后的`case`。

在进入到任何执行语句里后，结果一定要使用任何跳转语句脱离`switch`块。
不能顺延进入下一个`case`块或脱离`switch`块。一般使用`break`语句进行脱离。

# 循环

## while

`while`循环开始的判断和执行和`if`一样。区别在于，在进入语句块并执行完语句块后，
流程会回到`while`的条件判断处，再次判断条件，如果满足则再次执行语句块。直到条件不满足。

```csharp
while (Random.Shared.Next(100) > 4)
{
 Console.WriteLine("没有抽中SSR"); 
}
Console.WriteLine("抽中了SSR");
```

## do-while

`do-while`的条件判断在语句块结束。在语句块之间的间隙中，`do-while`和`while`都要进行条件判断。
区别在于，`do-while`不会执行最开始的条件判断了，所以语句块至少也会执行一次。

```csharp
string? s1;
do
{
 Console.WriteLine("初次启动或密码错误，请输入密码");
 s1 = Console.ReadLine();//从控制台读取输入。有输入时按下回车结束
} while (s1 != "123456");
Console.WriteLine("登录成功");
```

==do-while的条件后面是不跟大括号的，所以while后面是要加分号的==。

## for

`for`循环是一种以简便方式书写`while`循环，并含有循环专用的临时变量语法。

```csharp
for (int i = 0; i < 10; i++)
{
 Console.WriteLine("第" + i + "次丢骰子，丢出来" + Random.Shared.Next(1, 7));
}
```

`for`循环的括号里有3个部分，这三个部分的内容都可以不写，但分隔他们的`;`必须存在。

#### 声明部分

左侧的声明部分可以声明仅在这个循环中可用的变量，但这个变量可以跨越循环体。

等效于

```csharp
{
 int i = 0;
 while (i < 10)
 {
  Console.WriteLine("第" + i + "次丢骰子，丢出来" + Random.Shared.Next(1, 7));
  i++;
 }
}//有一个语句块包围这个for循环。使得for之外无法访问变量i
```

声明部分是一个变量声明语句，因此可以声明多个同类型的变量。

但变量声明语句在一条语句中，只能声明一种类型的变量。所以声明部分也只能声明一种类型的变量。

#### 条件部分

`for`循环的条件判断也是先判断再进入循环体的。

如果条件部分省略，则会认为是`true`。

#### 迭代部分

迭代部分是每次语句块执行完毕后执行。
和直接写在循环体里的区别在于，使用`continue`跳过循环体剩余部分时，不会跳过迭代部分。

如果不使用`continue`，那么希望循环的部分写在迭代部分或循环体里没有实质区别。

和声明部分不同的是，迭代部分可以有多条语句。使用逗号而非分号隔开。

#### 执行顺序

1. 声明部分
2. 条件判断
3. 循环体
4. 迭代部分
5. 回到2

## foreach

`foreach`循环是对于符合条件的特定类型的值，可以循环遍历它的内容。
一般而言，装载了不特定数量元素的类型都能使用`foreach`循环。

例如文本类型储存了多个字符类型。

```csharp
foreach (var item in "hello world")
{
 Console.WriteLine(item);
}
```

`item`是`foreach`中声明的迭代变量，和`for`循环不同的是，
一般情况下，`foreach`的迭代变量是不能由你修改的。

`foreach`的执行类似以下操作

```csharp
{
 var ator = "hello world".GetEnumerator();
 while (ator.MoveNext())
 {
  var item = ator.Current;
  {
   Console.WriteLine(item);
  }
 }
 ator.Dispose();
}
```

`foreach`循环就是检测他们是否具有合法的`GetEnumerator`，`MoveNext`和`Current`。

这三个内容包含了遍历操作的必要步骤——还有没有值，有什么值。

# 跳转

## break

在循环或`switch`中，使用`break`可以跳出本循环或`switch`。

`break`必须在上述的语句块中使用。如果不在这些地方则无法使用。
`break`对`if`不生效，`if`里的`break`仍会寻找最近的循环或`switch`对其生效。

```csharp
for (int i = 1; i < 10; i++)
{
 for (int j = 1; j < 10; j++)
 {
  Console.Write($"{i} * {j} = {i * j}\t");
  if (j > i - 1)
  {
   break;
  }
 }
 Console.WriteLine();
}
```

## continue

在循环中使用`continue`会略过本次循环中的剩余内容。
直接回到循环的条件判断中。如果是`for`循环，则会回到迭代部分，然后再进行条件判断。

`continue`对`switch`不生效。在循环内的`switch`里可以使用`continue`也是对最近的循环生效。
可以以此脱离`switch`而不必使用`break`。

```csharp
int ssr = 0;
for (int i = 0; i < 100; i++)
{
 int number = Random.Shared.Next(1, 101);
 if (number > 4)
 {
  Console.WriteLine("抽到r");
  continue;
 }
 Console.WriteLine("抽中了ssr！");
 ssr = ssr + 1;
}
Console.WriteLine("一共抽到了"+ssr+"个ssr");
```

## goto

使用`goto`必须先声明标签。
在一个语句前自定义名字+`:`标记这个语句。

之后在标签的作用范围内可以使用`goto`跳转到这个标签位置。

```csharp
G1: Console.WriteLine("初次启动或密码错误，请输入密码");
string? s2 = Console.ReadLine();//从控制台读取输入。有输入时按下回车结束
if (s2 != "123456")
{
 goto G1;
}
Console.WriteLine("登录成功");
```

`goto`起源极早期的编程语言，所以跳转非常自由。
c#保留了此命令但不建议使用。因为选择和循环包含一个语句块，能轻易看出要跳转在哪。
而`goto`的标签太过自由，使读者难以寻找。

但`break`和`continue`有个短板，即只能对当前层级的循环生效，不能一次脱离多个循环。
类似这些场景下可能存在不得不使用`goto`的情形。

除了自己声明标签外，`switch`的分支也可以作为标签使用。

```csharp
switch (Random.Shared.Next(6))
{
 case 1:
  goto case 2;
 case 2:
  goto default;
 default:
  break;
}
```

# 捕获异常

## 异常

```csharp
int i = 0;
Console.WriteLine(0 / i);
```

如果将整数0作为被除数，那么会得到以下输出

```
Unhandled exception. System.DivideByZeroException: Attempted to divide by zero.
   at Program.<Main>$(String[] args) in D:\Csharp12学习笔记\Program.cs:line 3
```

这段输出的意思是

- 未处理的异常
- 异常类型
- 伴随异常传递的消息
- 程序运行的调用栈
- 文件位置和代码位置

这套机制是c#的异常机制。在程序通知用户时，一般只能写一个错误码。

但对于开发人员来说，出现异常时，仍在程序运行阶段，
这个错误在程序内部传递时，可以传递更多的信息而不只是一个错误码。

异常附随一个终止当前方法的作用。并上抛这个异常。
直到有代码捕获这个异常，或是一直上抛到程序入口点导致整个程序终止。

因为异常的本意就是出现了不正常的情况，足以影响到程序的运行，
即便继续下去也会导致非预期的结果产生，所以会中断代码。

## try-catch

使用`try`可以捕获将要发生异常的语句。在`catch`中对异常进行类型判断。
这个过程类似于一个`if-else`的过程，

- 可以无限续接`catch`块。
- 未匹配的`catch`会顺延到下一个`catch`继续判断
- 如果有任何`catch`匹配则不再顺延
- 如果没有任何`catch`匹配则捕获失败，异常继续上抛。
- 最后一个`catch`可以省略条件不再判断类型。

但如果想要将捕获到的异常作为变量对其访问，则必须完整写出异常类型。

```csharp
try
{
 int i = 0;
 Console.WriteLine(0 / i);
}
catch (FileNotFoundException)
{
 Console.WriteLine("捕获到一个异常");
}
catch (IOException e)//将捕获到的异常赋值给变量e
{
 Console.WriteLine(e.Message);
}
catch
{
 Console.WriteLine("未匹配的异常");
}
Console.WriteLine("继续代码");
```

## try-finally

有些代码具有网络连接或其他需要外部资源的操作。
在出现异常后需要关闭这些连接。

使用`try-catch`时，无法确定是否会发生异常。
有可能不会完整运算`try`里的内容，有可能不会运行`catch`里的内容。

而关闭连接是无论执行是否出现异常都要执行的操作。
此时可以在`catch`后附加`finally`块。
在执行完`try`或`catch`后。会执行`finally`块的内容。

`finally`可以在没有`catch`的情况下使用。
但此时可以用不带条件的`catch`替换，

```csharp
try
{
 Console.WriteLine("打开网络连接");
}
catch (HttpIOException)
{
 Console.WriteLine("对方无响应，5秒后重连");
}
catch
{
 Console.WriteLine("未知异常");
}
finally
{
 Console.WriteLine("关闭网络连接");
}
```

## 抛出异常

使用`throw`语句跟随一个异常就可以抛出异常。

在`catch`块中，可以不跟随异常。这样会把捕获到的异常抛出。
捕获但是继续抛出，这个情形一般是记录日志等操作。

```csharp
try
{
 throw new Exception("抛出的异常");
}
catch
{
 throw;
} 
```

# 附录

## 嵌入语句

以下流程控制语句一般在后面需要跟随一个代码段。

- `if`
- `else`
- `while`
- `do-while`
- `for`
- `foreach`

但如果他们跟随的语句只有一条，则可以省略大括号。
代码段和作用范围仍然是存在的，因此不能是声明语句，因为没有意义。

```csharp
if (Random.Shared.Next(10)>4)
 Console.WriteLine("生成的随机数大于4");
else
    Console.WriteLine("生成的随机数小于5");
```

## 附加判断

在`switch`的`case`后，和`try-catch`的`catch`后，可以使用`when`附加一个普通的条件判断。

```csharp
int a = 0, b = 0;
switch (a)
{
 case 1 when a < b:
 case 2 when a < b:
  break;
}
try
{
 Console.WriteLine(a / b);
}
catch (IOException e) when (e.Message.Length < b)
{
}
catch when (a < b)
{
}
catch
{
}
```

## 流程预测

在声明变量时，可能初始值是在流程控制语句里赋值的。
那么声明变量时即便赋值初始值也会被覆盖。

但是，流程预测只有在有纯常量的情况下才能预测。
如果不能保证经过的代码会给他一个初始值，就会认为它可能没有初始值。

```csharp

//必定经过初始值赋值
int c;
if (Random.Shared.Next(5) > 2)
 c = 1;
else
 c = 2;
Console.WriteLine(c);

//必定经过初始值赋值
string? s3;
do
{
 Console.WriteLine("初次启动或密码错误，请输入密码");
 s3 = Console.ReadLine();//从控制台读取输入。有输入时按下回车结束
} while (s3 != "123456");
Console.WriteLine(s3);

//条件不是纯常量判断，不认为必定经过赋值初始值
int d;
for (int i = 0; i < 10; i++)
{
 d = i;
}
Console.WriteLine(d);

```
