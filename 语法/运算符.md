# 运算符

- 运算符的计算方式由类型自己定义。不同类型使用这些运算符的计算方式可能是不同的。
以下分类仅基于基本类型的计算方式。
- 位运算在作用于数字时，其目的通常与数学计算无关。而是对于数据的加密/解密，压缩/解压。

## 一元运算

一元运算是只有一个操作数的计算。

### 自身和相反数

在数字类型前使用`+`或`-`可以表达这个数字本身或这个数字的相反数。

### 取反

对整数类型前使用`~`符号，可以让这个数字里的所有二进制数字上的每一位进行翻转。

### 非

对于`bool`类型，使用`!`可以让逆转值。

## 二元运算

二元运算是有两个操作数的计算。

会先从左侧计算并得到值，然后从右侧计算并得到值，最后对这两个值进行运算。

### 加减

对两个数字类型，可以使用`+`，`-`进行相加和相减。

### 乘除，取余

对两个数字类型，可以使用`*`，`/`相乘和相除。
除此之外，可以使用`%`得到余数。
因为计算机计算除法时不可避免地会得到余数，所以余数单独做成了一个运算。

### 比较运算符

对于数字类型，可以使用`>`，`<`，`>=`，`<=`，`==`，`!=`进行大小比较。

其中，相等判断使用两个`=`连写，以区分赋值使用的单个`=`。
不等使用`!=`符号。

所有包含`=`的符号，`=`都在右边。顺序不可调换。

### 与和或

对于整数类型和`bool`类型，使用`&`和`|`可以对它们的二进制数字上的每一位进行逻辑计算。

对于`bool`类型，可以使用`&&`和`||`进行可以短路的逻辑运算。
即如果左侧已经能得到结果，不再计算和获取右侧值。

例如，整数的`0`不能作为除数，`i != 0 && 10 / i > 3`中先判断变量和`0`的关系，
再进一步决定是否要把他作为除数进行数学计算。这样可以避免出现`0`为除数的报错。

逻辑与为当所有条件均满足时，才算满足。
c#中当两者均为`true`/`1`时，结果才为`true`/`1`，否则为`false`/`0`。

逻辑或为当条件有任意满足时，就算满足。
c#中当两者有一个或两个`true`/`1`时，结果为`true`/`1`，否则为`false`/`0`。

### 异或

对于整数类型和`bool`类型，使用`^`可以对它们的二进制数字上的每一位进行逻辑计算。

异或逻辑是两者不同时为`true`/`1`。因为必须计算两者所以没有短路运算。

### 位移

对于整数类型，可以使用`>>`，`<<`把它的二进制数字上的每一位挪动。
这个符号右侧必须是整数类型，是挪动的位数。
结果上相当于乘或处了2的n次方。

挪动超出边界的，溢出的截断，补足的一律补`0`。

## 复合运算

二元运算的赋值语句，如果操作是把自己和一个值运算，然后赋值给自己，那么可以简写。

```csharp
int i = 10;
i += 10;
i >>= 2;
```

但二元运算中，两种短路的逻辑运算不行，他们可能不考虑右侧的值。

## 自增，自减

自增/自减的语法是连写`++`或`--`，可以在前面也可以在后面。

前后的区别在于表达式里同时赋值和取值，如果只当作`+1`的赋值操作，前面后面没有区别。

```csharp
int num = 1;
num++;
++num;
Console.WriteLine(num);
--num;
num--;
Console.WriteLine(num);
```

## 类型转换

类型转换分为继承转换和自定义的转换。
存在继承关系的类型，他们天然可以进行类型转换。
没有继承关系的类型，可以自己定义对他们的转换关系。

### 隐式转换

隐式转换是一种不会出现问题的类型转换。
他们可以直接转换为目标类型，就仿佛他们本身就是目标类型一样。

```csharp
int i = 0;
long l = i;
object o = i;
```

### 强制转换

强制转换是转换时可能出现问题的一种转换，需要明确写出来他们的类型转换。

所有隐式转换都可以冗余地以强制转换写出来。

```csharp
i = (int)l;//可能截断部分储存的数字，可能得到非预期结果
string s = (string)o;//实际储存的类型可能不是目标类型，可能报错
```
