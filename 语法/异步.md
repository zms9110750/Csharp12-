# 异步

## 异步方法

在方法前用`async`修饰可以使方法成为异步方法。
异步方法的返回值只能是以下类型

- `Task`及其泛型。
- `ValueTask`及其泛型。
- `void`。

异步方法会自动把返回的值包装为泛型的`Task`。
例如返回`Task<int>`类型只需要`return`一个`int`值。

```csharp
async Task<int> GetInt32Async(int i)
{
	return i;
}
Task<int> GetInt32(int i)
{
	return Task.FromResult(i);
}
```

## 等待

在异步方法中可以使用`await`来等待一个`Task`，`ValueTask`及它们的泛型。

当代码执行到`await`时：

- 如果右侧的`Task`没有执行完成，则视为方法已经完成，就像遇到`return`一样返回到调用者。
  - 没有执行完的部分储存到任务调度器继续等待。
	- 等待完成后通知任务调度器，调度器安排线程继续执行剩余部分。
- 如果右侧的`Task`执行完成，那么获取输出。

```csharp
Console.WriteLine("准备调用异步方法");
var taskHello = HelloAsync();
Console.WriteLine("回到调用方法处了");
await taskHello;

async Task HelloAsync()
{
	Console.WriteLine("异步方法开始了");
	await Task.Yield();
	Console.WriteLine("异步方法结束了");
}
/*
准备调用异步方法
异步方法开始了
回到调用方法处了
异步方法结束了
*/
```

被`await`等待的`Task`一般有以下情况

- 你创建的其他异步方法。
- 网络连接，文件访问等不需要进行计算的东西。
  - 相较于不使用异步而言，可以在等待期间执行其他操作。
  - 相较于开辟线程等待而言，节约了线程开销。
	- 操作系统执行这个操作实际上不需要线程参与。 
- 需要计算的东西。
  - 和多线程消耗的资源是一样的。
  - 使用异步让渡给后台线程计算，主线程继续其他操作。
	- 程序的主线程一般都需要绘制画面。主线程繁忙会导致窗口卡顿。

## 锁

任务调度器一般会让原线程继续执行未完成的任务。
但注明了不需要原线程的，任务调度器会用多线程处理。

多线程环境下，需要注意数据同步问题。
例如`i++`分为取值，计算，赋值三步。

如果一个线程取值，在完成赋值之前就有另一个线程取值，
那么它们执行完操作后也只相当于执行了一次操作。

```csharp
int num = 0;
Parallel.For(0, 1000, i =>
{
	for (int j = 0; j < 1000; j++)
	{
		num++;
	}
});
Console.WriteLine(num);
```

一种线程同步最简单的方法是加锁。
对任何一个引用类型使用`lock`锁住。
在执行完`lock`的范围前，
任何其他线程不能访问`lock`锁的实例。

```csharp
int num = 0;
object o = new object();

Parallel.For(0, 1000, i =>
{
	for (int j = 0; j < 1000; j++)
	{
		lock (o)
		{
			num++;
		}
	}
});
Console.WriteLine(num);
```

只有引用类型有同步块供加锁，值类型可以装箱后生成同步块。

## 死锁

如果

- 线程A锁住了a并需要b。
- 线程B锁住了b并需要a。

这种情况下谁也不能继续执行下去，这两个线程都将处于无限循环的卡死状态。
这种情况称为死锁。使用`lock`时应注意以下情况：

- 自己锁的东西，别人也能访问。	
  - 用于线程同步的东西应该是私有的。	
  - 字符串，`Type`，`this`也不应该用于锁。
- 自己锁东西的时候，还要使用有可能被锁的东西。
- 多个线程对可能加锁的资源需求顺序不一样。

`Task`应当使用`await`等待，不要调用`Wait`方法。

- 调度器会把`Task`给原线程。
- 调用`Wait`的就是原线程。
- 调度器等待原先程空闲以继续任务剩余部分。
- 线程在等待`Task`执行完毕以空闲。
  - 用`await`等待，线程就是空闲状态。 
