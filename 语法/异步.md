# 异步

## 异步方法

在方法前用`async`修饰可以使方法成为异步方法。
异步方法的返回值只能是以下类型，如果有，也包括它们的泛型版本。

- `Task`
- `ValueTask`
- `IAsyncEnumerator`
- `IAsyncEnumerable`
- `void`

异步方法会自动把返回的值包装为泛型的`Task`。
例如返回`Task<int>`类型只需要`return`一个`int`值。

```csharp
async Task<int> GetInt32Async(int i)
{
	return i;
}
Task<int> GetInt32(int i)
{
	return Task.FromResult(i);
}
```

## 等待

在异步方法中可以使用`await`来等待一个`Task`，`ValueTask`及它们的泛型。

当代码执行到`await`时：

- 如果右侧的`Task`没有执行完成，则视为方法已经完成，就像遇到`return`一样返回到调用者。
  - 没有执行完的部分储存到任务调度器继续等待。
	- 等待完成后通知任务调度器，调度器安排线程继续执行剩余部分。
- 如果右侧的`Task`执行完成，那么获取输出。

```csharp
Console.WriteLine("准备调用异步方法");
var taskHello = HelloAsync();
Console.WriteLine("回到调用方法处了");
await taskHello;

async Task HelloAsync()
{
	Console.WriteLine("异步方法开始了");
	await Task.Yield();
	Console.WriteLine("异步方法结束了");
}
/*
准备调用异步方法
异步方法开始了
回到调用方法处了
异步方法结束了
*/
```

## 为什么要使用异步方法

### 防止阻塞

CPU的可同时执行的线程数远小于操作系统中需要执行的线程数。
所以实际上，CPU运行程序是是依次执行各个线程。

一个线程有三种状态：

- 运行：CPU正在处理这个线程。
- 就绪：这个线程处于轮询队列等待CPU执行。
- 阻塞：这个线程不在轮询队列中。

阻塞意味着这个线程没有就绪，需要一定条件。
一般来说，这个条件是从硬盘/网络读取资源，或是写入资源。
又或者是让程序进入休眠状态（条件是等待计时器）。

调用异步方法可以放资源的交互发生在后台。
不影响当前线程的执行。

### 让渡线程

创建线程是需要消耗性能的。而c#中和资源交互的异步方法没有使用新线程。
因为交互资源是由操作系统监听的，一旦操作完成会发送一个信号给请求的程序。

如果等待的是一个计算任务，那么c#的API也会从线程池拿出线程来执行。
那既然没有节省资源，使用异步的意义是什么呢？

意义就在于让出执行权。程序的主线程是很重要的，不能卡顿。
窗体程序依靠主线程刷新窗口和监听用户交互。
例如用户点击暂停，取消，拖动窗口。这些操作都必须立刻响应。

## 锁

任务调度器一般会让原线程继续执行未完成的任务。
但注明了不需要原线程的，任务调度器会用多线程处理。

多线程环境下，需要注意数据同步问题。
例如`i++`分为取值，计算，赋值三步。

如果一个线程取值，在完成赋值之前就有另一个线程取值，
那么它们执行完操作后也只相当于执行了一次操作。

```csharp
int num = 0;
Parallel.For(0, 1000, i =>
{
	for (int j = 0; j < 1000; j++)
	{
		num++;
	}
});
Console.WriteLine(num);
```

一种线程同步最简单的方法是加锁。
对任何一个引用类型使用`lock`锁住。
在执行完`lock`的范围前，
任何其他线程不能访问`lock`锁的实例。

```csharp
int num = 0;
object o = new object();

Parallel.For(0, 1000, i =>
{
	for (int j = 0; j < 1000; j++)
	{
		lock (o)
		{
			num++;
		}
	}
});
Console.WriteLine(num);
```

只有引用类型有同步块供加锁，值类型可以装箱后生成同步块。

## 死锁

如果

- 线程A锁住了a并需要b。
- 线程B锁住了b并需要a。

这种情况下谁也不能继续执行下去，这两个线程都将处于无限循环的卡死状态。
这种情况称为死锁。使用`lock`时应注意以下情况：

- 自己锁的东西，别人也能访问。	
  - 用于线程同步的东西应该是私有的。	
  - 字符串，`Type`，`this`也不应该用于锁。
- 自己锁东西的时候，还要使用有可能被锁的东西。
- 多个线程对可能加锁的资源需求顺序不一样。

`Task`应当使用`await`等待，不要调用`Wait`方法。

- 调度器会把`Task`给原线程。
- 调用`Wait`的就是原线程。
- 调度器等待原先程空闲以继续任务剩余部分。
- 线程在等待`Task`执行完毕以空闲。
  - 用`await`等待，线程就是空闲状态。 
