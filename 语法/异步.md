# 异步

## 异步方法

在方法前用`async`修饰可以使方法成为异步方法。
异步方法的返回值只能是以下类型，如果有，也包括它们的泛型版本。

- `Task`
- `ValueTask`
- `IAsyncEnumerator`
- `IAsyncEnumerable`
- `void`

异步方法会自动把返回的值包装为泛型的`Task`。
例如返回`Task<int>`类型只需要`return`一个`int`值。

```csharp
async Task<int> GetInt32Async(int i)
{
	return i;
}
Task<int> GetInt32(int i)
{
	return Task.FromResult(i);
}
```

## 等待

在异步方法中可以使用`await`来等待一个`Task`，`ValueTask`及它们的泛型。

当代码执行到`await`时：

- 如果右侧的`Task`没有执行完成，则视为方法已经完成，就像遇到`return`一样返回到调用者。
  - 没有执行完的部分储存到任务调度器继续等待。
	- 等待完成后通知任务调度器，调度器安排线程继续执行剩余部分。
- 如果右侧的`Task`执行完成，那么获取输出。

```csharp
Console.WriteLine("准备调用异步方法");
var taskHello = HelloAsync();
Console.WriteLine("回到调用方法处了");
await taskHello;

async Task HelloAsync()
{
	Console.WriteLine("异步方法开始了");
	await Task.Yield();
	Console.WriteLine("异步方法结束了");
}
```
```
准备调用异步方法
异步方法开始了
回到调用方法处了
异步方法结束了
```

## 为什么要使用异步方法

### 防止阻塞

CPU的可同时执行的线程数远小于操作系统中需要执行的线程数。
所以实际上，CPU运行程序是是依次执行各个线程。

一个线程有三种状态：

- 运行：CPU正在处理这个线程。
- 就绪：这个线程处于轮询队列等待CPU执行。
- 阻塞：这个线程不在轮询队列中。

阻塞意味着这个线程没有就绪，需要一定条件。
一般来说，这个条件是从硬盘/网络读取资源，或是写入资源。
又或者是让程序进入休眠状态（条件是等待计时器）。

调用异步方法可以放资源的交互发生在后台。
不影响当前线程的执行。

### 让渡线程

创建线程是需要消耗性能的。而c#中和资源交互的异步方法没有使用新线程。
因为交互资源是由操作系统监听的，一旦操作完成会发送一个信号给请求的程序。

如果等待的是一个计算任务，那么c#的API也会从线程池拿出线程来执行。
那既然没有节省资源，使用异步的意义是什么呢？

意义就在于让出执行权。程序的主线程是很重要的，不能卡顿。
窗体程序依靠主线程刷新窗口和监听用户交互。
例如用户点击暂停，取消，拖动窗口。这些操作都必须立刻响应。

## 死锁

如果调用了`Task`上的`Wait`方法，那么这个线程会进入阻塞。
直到条件达成前，这个线程都处于休眠状态。

如果条件是一个资源交互操作，不需要线程参与，或是由其他的线程执行，都可以等到条件。

但如果等待的条件是一个运算任务，并且限定了是当前线程执行，那么就永远无法完成条件。
因为当前线程在休眠，不会执行运算，并且只有运算完成了才能执行这个运算。

这个情形称为死锁。一般的程序对画面的渲染都要求只能由主线程触发，不允许跨线程执行。
这时候就会出现限定当前线程执行的情况。
