# 方法

## 方法声明和调用

一个方法的声明包含多个部分。  
方法主体中可以声明一系列的语句。  

```
返回类型 名称 (参数列表)
{
	主体
}
```

在调用方法时，调用处的代码会暂停，开始执行被调用的方法。  
直到调用的方法执行完毕，回到调用处继续执行剩余代码。

所以，当调用方法时，就如同在此处写了方法里的代码。  

```
方法名(参数列表)
```

## 方法的返回值

方法在声明时需要写一个返回类型。  
主体中需要在合适的地方使用`return`语句返回一个值。

在调用方法完成后，会得到返回来的值。  
或者也可以不接收，忽略返回值。

```csharp
int r = Random100();//调用方法
Random100();//不使用返回值

int Random100()//声明方法
{
	return Random.Shared.Next(100);
}
```

### 无返回值

返回类型使用`void`可以表示这个方法不返回值。[^void]

[^void]:`void`是一个存在的类型。这个类型不允许声明变量，创建这种类型的值，作为泛型使用。

无返回值方法的主体中，可以不使用`return`语句结束方法。  
如果使用，后面不能接返回值。仍可作为流程控制语句结束方法。

### 多类型返回

c#中方法只允许一种返回类型。  
不能如果成功返回需要的值，如果失败返回`bool`值。  

需要指示成功失败时，可以使用以下代替方案：

- 返回类型使用`object`或其他的共同基类。让调用者做类型判断。
- 使用抛出异常，在失败时让调用者做异常处理。
- 使用数组元组等容器类型，无论成功失败都一律返回。
- 方法返回值返回`bool`指示成功失败，使用`out`参数返回需要的值

### 返回引用变量

方法的返回类型可以是引用变量。  
使用引用变量时，接受者可以选择接收值或接收引用。

```csharp
int c = Ref();
ref int d = ref Ref();

ref int Ref()
{
	int[] arr = [1, 2, 3, 4];
	return ref arr[0];
}
```

可以使用`readonly`修饰引用变量，  
强制接收者以`ref readonly`接收引用。

```csharp
int a = 10; 
ref readonly int d = ref Ref();

ref readonly int Ref()
{
	int[] arr = [1, 2, 3, 4];
	return ref arr[0];
}
```

### 不正常结束方法

有返回值的方法必须使用`return`来结束和脱离方法。  
但如果方法里有死循环不会脱离方法，  
或有抛出异常不正常脱离方法，  
那么可以不存在`return`。

```csharp
int While()
{
	while (true)
	{

	}
}
```

## 方法参数

方法的执行可能需要从外部获得值，  
方法可以定义参数来请求这些值。  
在调用方法时，调用方必须传入这些值。

方法和值的差别就体现括号上。所以即便是无参方法，  
无论在声明和调用时也需要带上一个括号。

```csharp
var i = Max(1, 2);

int Max(int a, int b)
{
	return a > b ? a : b;
}
```

### 形参实参

在方法定义时，参数列表里声明的参数称为形式参数。  
形参不需要进行初始化，在方法主体里视为他们有初始值。

在调用方法时传入的值称为实际参数。  
参数本质也是一种变量。  
传入实参就是调用方法时为形参创建变量和赋值初始值。

形参的参数数量，类型，顺序，共称为这个方法的**参数列表**。

### 隔离和捕获

方法内可以访问到外部的变量。  
直接访问称为捕获外部变量。[^不能捕获引用变量]

而如果方法定义了同名参数或变量，  
那么就无法访问到外部的同名变量。

[^不能捕获引用变量]:不能捕获引用变量

```csharp
int a = 1, b = 2, c = 3;

void Boo(int b)
{
	a = 10;//改变外部的变量a
	b = 11;//改变参数变量
	int c = 12;//自己创建一个变量
}
```

### 可选参数

形参允许使用常量赋值。  
在调用时可以不为这部分形参传入实参。[^仍然可以填入]  
可选参数必须在所有必填参数之后声明。

[^仍然可以填入]:仍然可以填入参数，以覆盖默认值。

```csharp
ShowTime();

void ShowTime(TimeOnly? time = null)
{
	time ??= TimeOnly.FromDateTime(DateTime.Now);
	Console.WriteLine(time);
}
```

### 命名参数

在调用方法时，可以指定形参名以改变传入顺序。  

- 如果有多个可选参数，可以用命名参数覆盖后面的可选参数而保留前面可选参数的默认值
- 在由模式匹配，`out`参数当场声明变量时，可以改变参数传入顺序来保持单条语句
- 在调用方法有歧义时，如果参数名不同可以用途命名参数指定重载来消除歧义

```csharp
Foo(b: 12 + 12 is int i, i: i);
//Foo(i2, 45 + 45 is int i2); 不可用

void Foo(int i, bool b)
{
	Console.WriteLine(i);
}
```

### 引用参数

参数可以使用引用变量。  
并且还有两种变体：`in`参数，`out`参数。

`in`参数会在方法里无法修改参数。
`out`参数会：
- 不读取实参的值
- 脱离方法前需要对其赋值
- 传入`out`参数可以使用没有初始化的变量
- 使用`out`参数可以当场声明变量

`ref`参数和`out`参数需要在调用处也需要写上对应关键字。  
`in`参数则可以省略。[^重载区别]

[^重载区别]:有方法重载，那么必须传入`in`才能调用到`in`重载版本。

```csharp
int i = -12;
ABS(ref i, out var negative);

void ABS(ref int value, out bool negative)
{
	if (value < 0)
	{
		negative = true;
		value = -value;
	}
	else
	{
		negative = false;
	}
}
```

### 不定长参数

在所有参数之后，可以使用`params`修饰一种集合类型。[^不能是引用]  
除了可以正常传入参数类型的值外，还可以改为传入这种集合的元素类型。

这些参数会先被打包为集合类型，然后传入方法。

[^不能是引用]:和可选参数同时存在时，不定长参数在可选参数之后。  
可选参数不能是引用参数。

```csharp
Min(1);
Min(1, 2, 3);
Min(1, 2, 3, -4, -5);

int Min(int min = 0, params int[] arr)
{
	foreach (var item in arr)
	{
		if (min > item)
		{
			min = item;
		}
	}
	return min;
}
```

## 方法重载

在方法中的方法称为**本地方法**。  
本地方法像变量一样不能重名，只能在所处大括号内访问。

在类成员中的方法可以重名，要求是他的参数列表不同。[^引用参数重载]  
在调用方法时会自动根据参数选取最合适的重载进行调用。  
但仍然可能存在无法分析的情况，此时会出现方法调用歧义。

```csharp
Console.WriteLine(null);
```

[^引用参数重载]:引用参数和普通参数可以重载。但引用参数的三种变体不能相互重载。