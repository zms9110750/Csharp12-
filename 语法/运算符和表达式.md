# 运算符

- 运算符的计算方式由类型自己定义。不同类型使用这些运算符的计算方式可能是不同的。
以下分类仅基于基本类型的计算方式。
- 位运算在作用于数字时，其目的通常与数学计算无关。而是对于数据的加密/解密，压缩/解压。

## 一元运算

一元运算是只有一个操作数的计算。

### 自身和相反数

在数字类型前使用`+`或`-`可以表达这个数字本身或这个数字的相反数。

### 取反

对整数类型前使用`~`符号，可以让这个数字里的所有二进制数字上的每一位进行翻转。

### 非

对于`bool`类型，使用`!`可以让逆转值。

## 二元运算

二元运算是有两个操作数的计算。

会先从左侧计算并得到值，然后从右侧计算并得到值，最后对这两个值进行运算。

### 加减

对两个数字类型，可以使用`+`，`-`进行相加和相减。

### 乘除，取余

对两个数字类型，可以使用`*`，`/`相乘和相除。
除此之外，可以使用`%`得到余数。
因为计算机计算除法时不可避免地会得到余数，所以余数单独做成了一个运算。

### 比较运算符

对于数字类型，可以使用`>`，`<`，`>=`，`<=`，`==`，`!=`进行大小比较。

其中，相等判断使用两个`=`连写，以区分赋值使用的单个`=`。
不等使用`!=`符号。

所有包含`=`的符号，`=`都在右边。顺序不可调换。

### 与和或

对于整数类型和`bool`类型，使用`&`和`|`可以对它们的二进制数字上的每一位进行逻辑计算。

对于`bool`类型，可以使用`&&`和`||`进行可以短路的逻辑运算。
即如果左侧已经能得到结果，不再计算和获取右侧值。

例如，整数的`0`不能作为除数，`i != 0 && 10 / i > 3`中先判断变量和`0`的关系，
再进一步决定是否要把他作为除数进行数学计算。这样可以避免出现`0`为除数的报错。

逻辑与为当所有条件均满足时，才算满足。
c#中当两者均为`true`/`1`时，结果才为`true`/`1`，否则为`false`/`0`。

逻辑或为当条件有任意满足时，就算满足。
c#中当两者有一个或两个`true`/`1`时，结果为`true`/`1`，否则为`false`/`0`。

### 异或

对于整数类型和`bool`类型，使用`^`可以对它们的二进制数字上的每一位进行逻辑计算。

异或逻辑是两者不同时为`true`/`1`。因为必须计算两者所以没有短路运算。

### 位移

对于整数类型，可以使用`>>`，`<<`把它的二进制数字上的每一位挪动。
这个符号右侧必须是整数类型，是挪动的位数。
结果上相当于乘或处了2的n次方。

挪动超出边界的，溢出的截断，补足的一律补`0`。

# 表达式

## 自增，自减

自增/自减的语法是连写`++`或`--`，可以在前面也可以在后面。

前后的区别在于表达式里同时赋值和取值，如果只当作`+1`的赋值操作，前面后面没有区别。

```csharp
int num = 1;
num++;
++num;
Console.WriteLine(num);
--num;
num--;
Console.WriteLine(num);
```

## 三元运算

三元运算类似于一个`if-else`语句，但这个表达式只能用于获取值。
`string s = i % 2 == 0 ? "偶数" : "奇数";`。
三元表达式的`?`左侧是一个条件，右侧是`:`隔开的两个值。

右侧的两个值必须能转为同一类型，这样整个表达式才能得到合理的类型。

三元表达式可以嵌套，但一般在右侧候选值嵌套，以便于理解。

```csharp
int i2 = 10;
string s2 = i2 < 2 ? "S"
 : i2 < 4 ? "A"
 : i2 < 10 ? "B"
 : "C";
```

## switch表达式

`switch`表达式类似于一个`switch`选择语句。但这个表达式也只能用来获取值。
`switch`表达式没有`()`包围需要判断的值，它判断的值是这个关键字左侧最接近的那个值。

```csharp
int i = 0;
string s = (i % 2) switch
{
 0 => "偶数",
 1 => "奇数",
 _ => "错误结果"
};
```

大于等于符号的`=`在右边。`switch`的分支臂的`=`在左边。

`switch`表达式分支左侧是判断匹配的值，右侧是此情况下返回的值。
右侧的所有值需要能转化为同一类型。

和`switch`选择不同的是，`switch`表达式使用`_`表示都不匹配的情况，但`switch`表达式的判断是有序的。
这个分支必须放在最后一个。

`switch`选择的判断匹配的值可以不包含所有情况，但如果运行时恰好遇到了无法匹配的情况，会报错。

另外，`switch`表达式也可以使用`when`进行一个次要判断。
在有次要判断切不为常量的情况下，`_`也不保证一定能匹配，可以不放在最后。

```csharp
int a = 1, b = 2;
var s2 = a switch
{
 _ when a < b => true,
 1 => true,
 2 when a > b => true,
 _ => false
};
```

## 内联抛出异常

在三元运算和`switch`表达式中，候选项可以用抛出异常代替。
抛出异常会中断运行，之后的类型判断没有意义，因此不会分析他们的类型。

但所有候选项中，至少有一个是普通的值，否则整个表达式不能计算值，本身没有意义。

```csharp
int i = 0;
string s = (i % 2) switch
{
 0 => "偶数",
 1 => "奇数",
 _ => throw new Exception("错误结果")
};
var s2 = i % 2 == 0 ? "偶数" : throw new Exception("此处不应该是奇数");
```

## 舍弃

自增自减同时具有赋值的效果。
如果想根据条件让不同的变量增减，
可以使用三元运算来缩减代码。

但三元运算本身不能独立成句，可以使用舍弃，伪装成一条赋值语句来独立成句。

```csharp
int a = 1, b = 2, n = 3;
_ = n < 6 ? a++ : b++;
```

`_`用作变量赋值时，表示舍弃这个值不操作。
但下划线本身也是一个有效的变量名，只能在没有声明过这个变量名时使用。

## 创建部分属性修改的新值

对于值类型，匿名类型，记录，可以使用`with`创建部分内容变动的新值，其他内容照原样复制。

```csharp
var student1 = (age: 12, name: "小明");
var student2 = new { age = 12, name = "小明" };

var student3 = student1 with { age = 15 };
var student4 = student2 with { name = "小丽" };
```

## 插值字符串

在字符串前加上`$`修饰，可以将字符串改为插值字符串格式。
插值字符串可以接收一对大括号的占位符，里面使用计算的值。

此时的大括号需要连写两个来转义。

在使用原始字符串时，可以加上多个`$`修饰，在字符串中，需要使用同等数量的连续`{`和`}`来启用和结束占位。

```csharp
string name1 = "小明";
int age1 = 12;
Console.WriteLine($"名字是:{name1}，年龄是{age1}，转义后的大括号{{}}");
Console.WriteLine($$$"""名字是:{{{name1}}}，年龄是{{{age1}}}""");
```

### 空格占位

在插值后，可以接一个逗号和一个常量，表示这个值至少要占多少个字符。
如果没有达到指定数量，就会用空格补齐。达到或超过则无事发生。
如果是正数，空格会补在前面，如果是负数，空格会补在后面。

```csharp
Console.WriteLine($"123456789012345678901234567890");
Console.WriteLine($"12|{456,6}0|23456789|{123,-7}|90");
```

### 格式说明符

在插值后（或空格占位后）可以加上冒号来描述这个类型的格式说明。
格式说明是由类型单独定义的。

```csharp
double e = 12.123456;
int f = 285;
Console.WriteLine($"{f:d5}");//00285，以前导0补足指定数量的数字
Console.WriteLine($"{f:x}");//11d，以16进制显示。字母部分的大小写取决于说明符的大小写
Console.WriteLine($"{d:f3}");//12.123，指定小数位数,会四舍五入或补0来达到指定位数
Console.WriteLine($"{d:e2}");//1.21e+001，科学计数法显示，e后面的数字即小数点后的有效数字，四舍五入
```

# 类型转换

类型转换分为继承转换和自定义的转换。
存在继承关系的类型，他们天然可以进行类型转换。
没有继承关系的类型，可以自己定义对他们的转换关系。

## 隐式转换

隐式转换是一种不会出现问题的类型转换。
他们可以直接转换为目标类型，就仿佛他们本身就是目标类型一样。

```csharp
int i = 0;
long l = i;
object o = i;
```

## 强制转换

强制转换是转换时可能出现问题的一种转换，需要明确写出来他们的类型转换。

所有隐式转换都可以冗余地以强制转换写出来。

```csharp
i = (int)l;//可能截断部分储存的数字，可能得到非预期结果
string s = (string)o;//实际储存的类型可能不是目标类型，可能报错
```

# 模式匹配

模式匹配是一系列对于值的类型进行判断，对内容与**常量**进行判断的判断。

模式匹配对值的类型判断仅判断继承关系，不判断类型自定义的转换，
但基本数字类型除外，他们的值过于基础可以互换。

通常以`is`运算符和`switch`的分支里进行启用。
当`switch`选择的`case`使用了模式匹配，就不能作为`goto`的标签使用。

## 类型转换

类型转换使用`as`尝试对值进行类型转换。
如果转换失败不会报错，而是会得到`null`。
`object o = 12;string s = o as string;`

## 类型判断

类型判断仅判断类型，得到一个`bool`值。

```csharp
object o = 12;
switch (o)
{
 case int:
 case string:
 default:
    break;
}
if (o is int)
{

}
bool b = o is string;
```

## 内容判断

### 成员

使用一对大括号可以在里面判断各成员的值是否满足要求。

内容判断可以嵌套。

```csharp
var student1 = (age: 12, name: "小明");
if (student1.name is { Length: 3 })
{     
} 
switch (student1)
{
    case { age: 12 }:
    case { name: "小刚" }:
    case { age: 16, name: { Length: 2 } }:
    case { }:
    break;
}
```

### 解构

对于可以解构的类型，在模式匹配时可以对其先解构值再进行匹配。

解构时，使用`_`舍弃部分值的匹配

```csharp
var student1 = (age: 12, name: "小明");
var s = student1 switch
{
 (12, { Length: 2 }) => "",
 (_, "小明") => "",
 _ => ""
};
```

### 范围

对于集合，可以使用范围对里面的元素进行判断。
`..`表示忽略这部分的元素，剩余部分表示仅匹配开头和结尾。

`..`在一个范围判断力最多用一次，因为多个存在时，无法判断中间的元素到底在第几个。
如果不使用`..`，那么连同这个元素的数量也有要求。

```csharp
switch ("hello")
{
 case ['h', 'e', .., 'o']:
 case [.., 'e']:
 default:
    break;
}
```

## 值判断

### 关系

和数字比较时可以加上`>`，`<`，`>=`，`<=`，如果判断相等则不需要加符号。
如果判断不相等，则需要使用逻辑的非

### 逻辑

在有多个判断需要联合时，可以使用逻辑判断。
`not`非，`and`与，`or`或。

```csharp
object o = "";
if (o is int and > 3 and < 9 and not 4)
{
}
if (o is int or string { Length: 2 } or bool)
{

}
```

## 声明

在类型判断后可以加这个类型的内容判断。
如果整个判断只涉及到一个类型，那么可以同时声明一个变量，表示匹配成功时创建这个变量。

在内容判断时，可以对内容进行声明。

```csharp
object point = (x: 1, y: 3);
switch (point)
{
 case int i:
    Console.WriteLine(i + i);
    break;
 case string { Length: var len }:
    Console.WriteLine(len);
    break;
 case (int a, int b) when a < b:
    Console.WriteLine(a + b);
    break;
}
```

不匹配的声明会视为未赋值的变量，配合流程控制视其总是被赋值过。

```csharp
string s2 = "";
if (s2 is { Length: 2 } s3)
{
 Console.WriteLine(s3);
}
else if (s2 is string s4 and not { Length: > 4 })
{
 Console.WriteLine(s4);
}
else if (s2 is not string s5)
{ 
 //此处s5是未赋值的变量
}
else
{
 Console.WriteLine(s5);
}
```

范围判断时，可以把范围作为声明。只想声明不想进行判断的，可以使用`var`作为类型。

```csharp
if ("hello" is ['h', .. var p, 'o'])
{
 Console.WriteLine(p);
}
```

# 运算顺序

## 复合运算

二元运算的赋值语句，如果操作是把自己和一个值运算，然后赋值给自己，那么可以简写。

```csharp
int i = 10;
i += 10;
i >>= 2;
```

但二元运算中，两种短路的逻辑运算不行，他们可能不考虑右侧的值。

## 修改值的同时获取值

c#中只有`void`类型不能访问，他们只有从方法调用中得到。即便赋值语句可以独立成句，他也不是`void`类型。

赋值语句也是一个表达式，也可以得到值。
而自增，自减语句也一样，并且仅在需要取值时，他的`++`写在前面和后面才有区别。

在普通的赋值语句时，被复制的变量的值会被无视。仅取赋值右侧的值。

```csharp
int a = 10, b = 11, c = 12;
int d = (a = 21) + (b = 22) + (c = 23);
a = b = c = d = 30;
```

在符合复制语句中，会先执行赋值，然后取这个变量的值。

```csharp
int a = 10, b = 11, c = 12;
int d = (a += 20) + (b += 30) + (c += 40);//分别取30，41，52，得到123
a += b += c += d += 30;
```

自增和自减，如果`++`写在前面，那么先计算和赋值，再取赋值后的结果。
如果写在后面，那么先缓存当前的值，然后执行计算和赋值，取到的是原来的值。

```csharp
int num = 0;
Console.WriteLine(num);//0
Console.WriteLine(num++);//0
Console.WriteLine(num);//1
Console.WriteLine("====");
Console.WriteLine(num);//1
Console.WriteLine(--num);//0
Console.WriteLine(num);//0
```

## 运算顺序

运算顺序可以使用小括号改变,小括号内的会先算。

1. 运算顺序优先级最高的是成员访问，会先链式访问到最后结果再取值。

```csharp
Console.WriteLine(-2.ToString().Length);//求得字符长度1后，对1取相反数
Console.WriteLine((-2).ToString().Length);//对整个数字-2转为字符串，然后计算字符数量
```

2. 然后是所有一元运算，他们表示对自己之后的一个值进行修饰。
`+x、-x、x、~x、++x、--x、^x、(T)x`

```csharp
Console.WriteLine((int)3.6 + 3.6);//只有前面的数字转为int，以截断小数的3和3.6相加
Console.WriteLine((int)(3.6 + 3.6));//相加得到7.2后，对7.2截取小数得到7
```

3. 然后是`switch、with`两个表达式，他们对紧跟着自己的前面一个值进行运算。
4. 乘除取余。虽然数学运算才有这种优先级，但这个规则也扩散到了所有类型。
5. 加减法
6. `x << y、x >> y`的位移运算。他会先等待左侧数算出来。
7. `x < y、x > y、x <= y、x >= y、is、as`关系判断。
8. `x == y、x != y`相等和不相等的关系判断。
9. 逻辑与
10. 逻辑异或
11. 逻辑或
12. 短路逻辑与
13. 短路逻辑或
14. 三元运算
15. 所有赋值

## 独立成句

c#中，一条可以单独放置的语句，必须是以下情况之一

- 方法调用
- 声明变量
- 变量赋值
- 自增，自减，
- `new`构造

```csharp
"hello";  
new string("hello");//使用new进行构造是c#中正规的构造值的方式。
//上面两种方式得到的值是一样的，但使用new的语句可以独立成句，字面量则不行。
```

以上情况指的是此语句里最后计算的结果，不考虑中间的过程。

```csharp
"hello".ToString().Length;//最后是获取值，不行。
"hello".Length.ToString();//最后是调用方法，可以

"hello" + "world".ToString();//先调用方法，把结果和另一方相加。相加是最后计算的，不行。
("hello" + "world").ToString();//使用括号改变顺序，先相加，最后是调用方法。可以
```
