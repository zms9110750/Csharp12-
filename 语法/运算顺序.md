# 运算顺序

## 修改值的同时获取值

c#中只有`void`类型不能访问，他们只有从方法调用中得到。即便赋值语句可以独立成句，他也不是`void`类型。

赋值语句也是一个表达式，也可以得到值。
而自增，自减语句也一样，并且仅在需要取值时，他的`++`写在前面和后面才有区别。

在普通的赋值语句时，被复制的变量的值会被无视。仅取赋值右侧的值。

```csharp
int a = 10, b = 11, c = 12;
int d = (a = 21) + (b = 22) + (c = 23);
a = b = c = d = 30;
```

在符合复制语句中，会先执行赋值，然后取这个变量的值。

```csharp
int a = 10, b = 11, c = 12;
int d = (a += 20) + (b += 30) + (c += 40);//分别取30，41，52，得到123
a += b += c += d += 30;
```

自增和自减，如果`++`写在前面，那么先计算和赋值，再取赋值后的结果。
如果写在后面，那么先缓存当前的值，然后执行计算和赋值，取到的是原来的值。

```csharp
int num = 0;
Console.WriteLine(num);//0
Console.WriteLine(num++);//0
Console.WriteLine(num);//1
Console.WriteLine("====");
Console.WriteLine(num);//1
Console.WriteLine(--num);//0
Console.WriteLine(num);//0
```

## 运算顺序

运算顺序可以使用小括号改变,小括号内的会先算。

1. 运算顺序优先级最高的是成员访问，会先链式访问到最后结果再取值。

```csharp
Console.WriteLine(-2.ToString().Length);//求得字符长度1后，对1取相反数
Console.WriteLine((-2).ToString().Length);//对整个数字-2转为字符串，然后计算字符数量
```

2. 然后是所有一元运算，他们表示对自己之后的一个值进行修饰。
`+x、-x、x、~x、++x、--x、^x、(T)x`

```csharp
Console.WriteLine((int)3.6 + 3.6);//只有前面的数字转为int，以截断小数的3和3.6相加
Console.WriteLine((int)(3.6 + 3.6));//相加得到7.2后，对7.2截取小数得到7
```

3. 然后是`switch、with`两个表达式，他们对紧跟着自己的前面一个值进行运算。
4. 乘除取余。虽然数学运算才有这种优先级，但这个规则也扩散到了所有类型。
5. 加减法
6. `x << y、x >> y`的位移运算。他会先等待左侧数算出来。
7. `x < y、x > y、x <= y、x >= y、is、as`关系判断。
8. `x == y、x != y`相等和不相等的关系判断。
9. 逻辑与
10. 逻辑异或
11. 逻辑或
12. 短路逻辑与
13. 短路逻辑或
14. 三元运算
15. 所有赋值

## 独立成句

c#中，一条可以单独放置的语句，必须是以下情况之一

- 方法调用
- 声明变量
- 变量赋值
- 自增，自减，
- `new`构造

```csharp
"hello";  
new string("hello");//使用new进行构造是c#中正规的构造值的方式。
//上面两种方式得到的值是一样的，但使用new的语句可以独立成句，字面量则不行。
```

以上情况指的是此语句里最后计算的结果，不考虑中间的过程。

```csharp
"hello".ToString().Length;//最后是获取值，不行。
"hello".Length.ToString();//最后是调用方法，可以

"hello" + "world".ToString();//先调用方法，把结果和另一方相加。相加是最后计算的，不行。
("hello" + "world").ToString();//使用括号改变顺序，先相加，最后是调用方法。可以
```

## 舍弃

自增自减同时具有赋值的效果。
如果想根据条件让不同的变量增减，
可以使用三元运算来缩减代码。

但三元运算本身不能独立成句，可以使用舍弃，伪装成一条赋值语句来独立成句。

```csharp
int a = 1, b = 2, n = 3;
_ = n < 6 ? a++ : b++;
```

`_`用作变量赋值时，表示舍弃这个值不操作。
但下划线本身也是一个有效的变量名，只能在没有声明过这个变量名时使用。