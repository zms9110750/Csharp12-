# 自定义类型

c#中，类型定义必须处于顶级语句之下。  
一个最简单的类定义如下：

```csharp
class C;
```

类可以像方法一样有参数列表和方法体。  

- 类的“方法体”并不是真正的“方法体”，他们能写的东西不一样
- 类的参数列表和方法体是独立的，可以都存在 / 都不存在 / 只存在其中一个
- 如果写了“方法体”就不要用分号结尾

```csharp
class MyClass()
{
}
```

## 结构,类,记录

定义类前面的关键字可以有多种选择，会有不同的特点

- `class`：类，引用类型。
- `sturt`：结构，值类型。
    - 结构常用于高性能代码中，为此他还有专属的修饰符：
    - `readonly`：只读，创建完成后内容不可变。  
    在方法的`in`参数引用传递后，如果调用方法，仍然有可能导致内容更改。  
    如果会更改，在方法里仍然会复制出一个结构，而不再是引用传递。  
    只读结构强行要求所有内容只读，以避免结构的复制。
    - `ref`：引用，结构里可以包含引用变量和引用结构。  
    引用变量是指针的一种，为了保证使用安全，引用结构有很大限制。  
    例如不能创建数组，作为泛型类型，作为非引用结构的类成员，被方法捕获。
- `record`：记录，根据类后面的参数列表自动合成成员。
    - `record class`可以省略掉`class`。  
    - `record sturt`合成的成员可以赋值，`record class`和`readonly record struct`不行。
    - 自动合成`ToString`方法
    - 根据参数列表自动合成解构方法，使得可以像元组一样解构

```csharp
Point point = new Point(20, 30);
var (a, b) = point;//像元组一样解构

record struct Point(int X, int Y);
record Rec { }
class Cla(int X, int Y);//不具有record也没有内容时，参数列表没有意义
```

## 对象初始化器

在创建一个对象后对他的成员进行赋值，可以用对象初始化器语法。

- 除了可以为`init`访问器的属性赋值外，与直接赋值没有区别
- 对象初始化器的执行顺序和自己赋值一样，晚于所有初始化过程  
  也就是说对象初始化器的赋值会覆盖之前初始化过程中的值
- 对象初始化器中如果不是给整个集合赋新值，那么可以对元素初始化
    - 不需要和集合长度等长

```csharp
Point2 point = new Point2(2, 2, new int[10]) { X = 20, Y = 30, Arr = { [0] = 1 } };

record struct Point2(int X, int Y, int[] Arr);
```

### 克隆

如果类型定义有`record`或`struct`之一，则可以使用`with`表达式。  
`with`表达式可以使用对象初始化器语法进行覆写一些值，  
没写的值都赋值被克隆的对象。

```csharp
var point2 = point with { X = 30 };//Y的值会复制point.Y
```

## 访问权限

在类型内部里定义的东西，可以在所属大括号外访问到。  
如果有访问权限的话。

```csharp
Rec2.Rec3 rec = new Rec2.Rec3();//不可访问，有保护级别

record Rec2
{
	record Rec3;
}
```

访问权限有以下修饰符：

1. `public`（公开）：任何地方都能访问
    - 接口的实例成员默认为此权限
2. `protected  internal`：本程序集的类或派生自该类的类
2. `protected`（保护）：派生自该类的类
2. `internal`(内部)：本程序集
    - 最外层的类定义默认为此权限
    - 程序集在解决方案里是一个**项目**。
    - 这个范围是为**我能用，而别人不能用**的范围。  
    除非被别人拿到源码，否则引用项目，或引用`dll`都不能访问。
2. `private protected`：本程序集里且派生自该类的类
2. `private`（私有）：仅限所属大括号内  
    - 默认类成员（包括类型定义）都为此权限

```csharp
Rec2.Rec3 rec = new Rec2.Rec3();//可以访问

record Rec2
{
	public record Rec3;
}
```