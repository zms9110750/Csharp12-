# 元组和数组

元组和数组都是两种能把多个值打包为一个值的类型。

## 元组

元组可以打包任意数量，任意类型的值。  
元组的宣称类型规定元素的**类型**，**数量**，**顺序**。

### 声明

元组的声明是用小括号打包，在里面填写多个（至少2个）类型并使用逗号隔开。  
使用`Item1`,`Item2`,`Item3`等等来访问元素。

```csharp
(int, string) student = (12, "小明");//声明一个元组
int age = student.Item1;
string name = student.Item2;
```

### 元素命名

在源码中可以为元素命名以代替默认的名字。[^不能占用]
按优先级顺序，有以下三种命名方式：

1. 类型命名：在声明元组类型时，在类型后写了名字，那么就会命名这些元素。
2. 值命名：使用`var`声明元组时，如果值在打包时进行了命名，那么会使用这些名字。
3. 推断命名：使用`var`声明元组时，如果值用的是变量或属性，那么会使用变量名。

```csharp
(int age, string name) student2 = student;//类型命名
var student3 = (age: 12, name: "小明");//值命名
var student4 = (age, name);//推断命名

Console.WriteLine(student4.age);
Console.WriteLine(student4.name);
```

[^不能占用]:命名后仍然可以使用原本的`Item1`访问元素。  
并且这些名字有元素使用时，不能为其他元素定义这些名字。  
这些名字只在源码中存在，编译时会替换为`Item1`这种名字。

### 解构

元组可以为打包的多个变量进行赋值，或声明这些变量。[^自定义解构]

```csharp
(age, name) = student;//解构一个元组。
var (age2, name2) = student;//解构同时声明变量
(var age3, _) = student;//只有部分变量需要声明时，给单独的地方写上类型
						//不需要赋值的变量，使用舍弃

(age, age2) = (age2, age);//利用解构元组交换两个变量。
```

[^自定义解构]:自定义类型可以定义解构方法达到类似效果。  
需要具有`public void Deconstruct`，且参数全为`out`参数的方法。  
也可以是扩展方法，但元组只能按默认的解构，扩展解构方法无效。

## 数组

数组可以打包同种类型的多个变量。  
宣称类型不限制元素数量，可以接受任何数量的数组值  
但创建完毕的数组值不能再改变数量。[^数组长度不变]

[^数组长度不变]:不能改变是指在不为变量重新赋值的情况下，这个变量的长度是不变的。

### 创建和访问

数组使用`new`构造[^有默认值]，使用中括号填写元素数量。  
访问内容时使用索引器[^可用变量]进行访问。  
**索引从0开始**，超出范围会报错。

[^有默认值]:在创建数组时，他内部的元素会初始化（都是默认值)。  
所以内部的元素可以在不赋值的情况下就读取。

[^可用变量]:数组的索引器里可以写变量，以配合循环使用。

```csharp
var arr1 = new int[4];
arr1[0] = 1;
arr1[1] = 2;
arr1[2] = 3;
arr1[3] = 4;
Console.WriteLine(arr1[2] * arr1[3]);
```

## 集合表达式

集合类型可以使用集合表达式进行初始化。  
集合表达式没有类型，接收的变量必须是类型明确的。

集合表达式会用表达式里值和数量一起初始化[^不能既要又要]。  
[^不能既要又要]:不能既想创建100个元素的数组，同时只初始化前几个元素。

```csharp
int[] arr2 = [1, 2, 3, 4];//数组
List<int> list = [1, 2, 3, 4];//列表
```

集合表达式中，可以在一个可迭代的值前面加上`..`，  
意味展开他的元素，把这些元素作为初始化的值。

```csharp
char[] charArray = [.. "hello", .. "world"];
```

### 交错数组和多维数组

数组的类型是指定类型后加`[]`。  
数组也是一种类型，所以有数组的数组。  
除此之外，`[]`内可以添加逗号，形成多维数组。

```csharp
int[][][] arr3 = new int[4][][];//交错数组
int[,,] arr4 = new int[2, 3, 4];//多维数组

arr3[0] = [[1, 2, 3], [2, 3, 4], [3, 4, 5]];
Console.WriteLine(arr3[0][1][2]);
Console.WriteLine(arr4[1, 2, 3]);
```

#### 数组遍历

数组可以通过访问他的`.Length`来确定元素数量，以在循环中使用。  
多维数组则需要通过`.GetLength()`方法来确定每个维度上的元素数量。

```csharp
for (int i = 0; i < arr3.Length; i++)
{
	arr3[i] = new int[2][];
	for (int j = 0; j < arr3[i].Length; j++)
	{
		arr3[i][j] = new int[3];
		for (int k = 0; k < arr3[i][j].Length; k++)
		{
			arr3[i][j][k] = i * j * k;
		}
	}
}

for (int i = 0; i < arr4.GetLength(0); i++)
{
	for (int j = 0; j < arr4.GetLength(1); j++)
	{
		for (int k = 0; k < arr4.GetLength(2); k++)
		{
			arr4[i, j, k] = i * j * k;
		}
	}
}
```

### 索引和范围

集合类型[^不包括多维数组]的索引器可以在数字前加上`^`[^Index类型]，以表示倒数。  
例如，`arr[^1]`会被编译为`arr[arr.Length - 1]`。[^自动合成的Index索引器]

集合类型的索引器里可以用`..`连接两个索引[^Range类型]，  
表示一个范围并截取[^自动合成的Range索引器]这段数组。  
首尾的索引可以省略以表示取到底。例如：  
`var arr2 = arr1[1..2]`，`var str = "hello"[^2..]`，`var str2 = "hello"[..]`。

[^不包括多维数组]:只有索引器里填写一个参数的集合类型可用。所以多维数组不能使用这些功能。

[^Index类型]:这样构造的是`Index`类型。构造时不能使用负数。  
他记录了这个索引数值，和是否是倒数的。

[^自动合成的Index索引器]:自定义类型如果满足以下条件，也可以使用`Index`作为索引。  
并且当索引为倒数时会改为调用`arr[arr.Length - index]`或`arr[arr.Count - index]`：
- 具有`Length`（优先）或`Count`，且类型为`int`，是具有`get`的属性。
- 有一个接收`int`的索引器。
- 没有接受`Index`或`object`的单参数索引器。



[^Range类型]:这样构造的类型是`Range`类型，包含两个索引。  
分别表示开头的索引和结尾的索引。

[^自动合成的Range索引器]:自定义类型如果满足以下条件，也可以使用`Range`作为索引。
并在运行时会改为调用
```csahrp
var (offset, length) = range.GetOffsetAndLength(arr.Count);
arr.Slice(offset, length);
```
- 具有`Length`（优先）或`Count`，且类型为`int`，是具有`get`的属性。
- 有一个方法`Slice`接受两个`int`作为参数
- 没有接受`Range`或`object`的单参数索引器。