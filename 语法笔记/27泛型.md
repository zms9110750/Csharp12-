# 泛型
c#是强类型语言，不同类型具有不同职责。
但类似于数组这样的类型，他们是一种容器，包装。
他们只帮你管理变量。
尽管他们不会用到类型的任何职责，但他们依然对类型有要求。

这时候可以使用泛型。
## 泛型类
在一个类名后面以尖括号声明一个名字，
这个名字在类中会被认为是一个有效的类型。
泛型参数的命名通常以大写字母`T`开头，
多个泛型参数在尖括号内以逗号隔开。

泛型也可以适用于记录，结构，委托。
但扩展方法不能存在于泛型类中，
只能在普通的静态类中声明泛型方法。

在创建泛型类的变量，和调用构造器时，
需要带上尖括号，并依次填入可用的类型。
可用是指，`int`这种真实存在的类型，
或者在泛型类中，这个类自己声明的泛型。

## 泛型方法
在方法名后面，参数列表之前，也可以使用尖括号声明泛型方法。
以此法声明的泛型是额外的，仅对于此方法存在的。
泛型方法声明的泛型如果有和所处类同名的泛型参数，
会覆盖掉导致无法访问类的泛型。

属性，索引器，事件不能额外声明泛型，他们只能使用所处的类声明的泛型。

调用泛型方法时，如果方法参数使用了泛型，
并且仅靠参数类型就能推断出全部的泛型类型，
那么调用的时候可以省略方法上的泛型。
（不含构造器）

# 泛型约束
一些情况下，即便用了泛型，也依然希望使用部分类型的功能，
此时可以使用泛型约束。只有满足条件的类型才能调用这样的泛型类/泛型方法。
如此一来，你可以在这样的泛型类或泛型方法中调用他们对应的方法。

## 声明约束
在泛型类的继承列表后，泛型方法的参数后，他们的主体前，
使用`where`关键字+泛型参数+`:`指定约束。
同一个泛型参数的多个约束之间用逗号隔开，
多个类型的约束使用多个`where`指定和隔开。

## 派生自类
如果要求泛型类型参数代表的类型派生自某一类型，
只需要直接写类型名。如果只要求是一个引用类型，那么使用class。
显然，类型约束不能是密封类或静态类。类型名可以是另一个泛型类型参数

具有类型约束后，可以调用此类型有权限访问的实例方法和属性。

## 是结构
是一种值类型，使用`struct`。
不能是可为空的值类型使用`notnull`。
必须是非托管类型使用`unmanaged`。

非托管类型是指不包含任何引用类型字段的值类型，
且它的字段的字段，一直递归下去，都不包含。

## 实现接口
实现接口只需要直接写接口名。
但是正如继承时的语法一样，接口约束必须写在类约束或结构约束之后。 

可以从泛型实例上调用接口方法。
或者从泛型参数上调用接口的静态抽象方法。

## new()
这个约束要求目标类型具有公共无参构造器。具有此约束的类型可以在函数中调用这个构造器。
`new()`约束必须放在约束列表的最后一个。


