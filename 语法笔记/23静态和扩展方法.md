# 静态
## 实例
实例是指一个独立的东西。可以说"这个"，"那个"，"一个"的物件。
例如有两个人，其中一个人的身高怎么变，都不会影响另一个人的身高。
他们是独立的。并且这个人是可以说“这个”的。

实例属性则必须要搭配实例来使用。例如身高是一个实例属性。
在讨论人的身高的时候，必须拿出一个人，说这个人的身高xxx。

## 静态
静态则不需要，静态只需要拿出这个概念就能讨论。
例如人有两条腿，两只手。这个属性是不需要拿出一个人来讨论的。

## 静态成员
静态成员是使用`static`关键字修饰的成员。

可以像实例成员一样声明字段，属性，事件，方法。但索引器不行。
此外，静态构造器和终结器一样是系统调用的，所以必须是无参的，且不能有访问权限修饰。

## 静态和实例的执行顺序
在以任意方式第一次访问一个类型时，进行初始化。
首先根据定义顺序从上到下对字段执行初始值赋值。
然后执行静态构造器。

静态字段的初始值赋值是可以相互引用的。但还未赋值的，会用`default`代替。

在创建类的实例时，也是按照先字段初始值，再构造器的顺序。
而这个时候，由于静态成员已经初始化完毕了，实例成员可以借助静态成员进行赋值。
但实例成员不能借助其他实例成员进行赋值，即使定义顺序在之前也不行。

## 常量
常量完全符合`static readonly`的要求，因此也会当作静态成员。

## 调用静态成员
在类的外部，可以使用类名访问静态成员。类似于`Popole.Hand`。

在类的内部，如果方法参数与静态成员有重名，也可以使用此方式访问到静态成员。
此外，如果方法参数与实例成员重名，可以使用`this.`的方式来访问实例成员。
# 扩展方法
## 静态类
只有普通类可以在类上面修饰为静态的，记录，结构不行。
使用静态修饰类以后，这个类便不能存在任何实例成员，包括构造器。
这意味这这个类不会存在任何实例，仅作为一个工具类。

## 扩展方法
在顶级静态类中，静态方法的第一个参数可以使用`this`修饰。
例如`public static void Hello(this int s)`。

如果命名空间引用了这个定义扩展方法的类，
则这个静态方法可以直接从这个参数的实例上调用，就好像就是他自己的实例方法一样。

要求是顶级类，是因为嵌套类是可以访问定义类的私有成员的。
扩展方法要求应该和你自己执行一系列操作一样，不应该访问原本不能访问的东西。

# 静态引用
在引用命名空间时，可以使用`using static`引用一个具体的类型。
然后，这个类里的所有静态成员（包括常量）都不需要使用类名，可以直接访问。