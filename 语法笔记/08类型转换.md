# 类型转换
## 隐式自定义类型转换
这类类型转换通常不会出现错误或者非预期的情况。
可以直接为目标变量赋值，就如同自己就是目标类型。

例如`int`的范围完全涵盖了`byte`，`long`的范围完全涵盖了`uint`。
所以`byte`值能直接为`int`类型变量赋值。

8种整数类型都有着这种规则，字节数更多的变量可以装载字节数更少的值
(但不能是有符号值，转换为无符号类型)。

而小数类型中，`double`可以装载`float`。
三种小数类型可以装载全部的整数类型。

## 显式自定义类型转换
另一些类型的转换可能出现错误，或者非预期的情况。
这种转换需要一步额外的步骤：在值前面使用小括号，并写明类型，以表示转换为目标类型。

例如小数类型转换为整数类型，他们的小数部分将被截断。
多字节的整数类型转换为少字节的整数类型，他们多出来的内存会被截断。
有符号类型和无符号类型的相互转换。不在共有部分的数字，会被解析为不同的结果。[^1]

[^1]:不过他们的内存在此期间不会变化。在强制转换回去，可以还原原本的数值。

## 基于继承的类型转换
一个类型继承另一个类型时，会获得他的全部职责。那么，就可以当作那个类型使用。
（香蕉类型继承自水果类型。水果能干什么香蕉就能干什么）
在安全代码下，所有的值都有共同的基类`object`。他可以装载任何变量。

`int`继承自`object`，所以一个`object`值有可能是`int`值。
这种转换同样要在前面加括号写上目标类型，说明可能出错。

## 工厂模式构造值
工厂模式是说根据配置的不同，创造出不同的值。
屏幕识图根据图片（配置）识别出文字（创造值）就是一种工厂模式。
类似的，把文字转化为数字，也可以使用工厂方法。

所有数字类型都有一个`Parse`方法，接收一个字符串，来构造一个数字。
