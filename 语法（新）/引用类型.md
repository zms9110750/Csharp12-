# 引用

## 指针

当一个数据过于巨大的时候，整个复制是极为消耗性能的。  
因此有一种传递方法，将这个数据的所在地址复制和传播。

举例来说，你看到一个有趣的视频想发给朋友。  
如果把整个视频下载，再把整个文件传给朋友，那要很久。  
但是如果直接把网址发过去，那就快多了。

这样做也有缺点。这份数据不属于你，  
可能你朋友网速不好，看视频会很卡。  
可能过了几天这个视频下架了，或者要VIP了。

## 引用类型

c#中，数组，`class`，接口，都是引用类型。  
他们在源码中的传递都是他们的地址。  
当访问他们的内容时，会寻着地址找到数据。  
由此，引用类型有一些特点：

- 引用类型的变量不储存他的内容
- 把引用类型直接赋值给另一个变量，这两个变量访问到的内容是共享的
- 对引用类型的变量加上`只读`，不能阻止他的内容改变
- 引用类型的默认判断方式是判断他们的地址是否一样（引用到相同数据）

## 不可变性

面向对象编程概念里的对象，是本身具有一些数据，并且可以使用他的方法进行修改。  
但在c#中有很多类型，只希望他是个只能读取的数据，设计理念不希望他能改变自己身上的数据。 

一般来说，如果一个类型的方法会在自己身上改变数据，  
那么方法返回`void`，下次再访问就会发现数据变了。  
如果一个类型是不可变的，那么他的方法会给你一个新值，
你需要用变量接收他。新值是改变后的值，而他本身不会变化。

```csharp
int[] arr = [4, 2, 3, 1];
int[] arr2 = arr;

Console.WriteLine(arr2[0]);//4
arr[0] = 8;//改变arr却能影响arr2的值
Console.WriteLine(arr2[0]);//8
Array.Sort(arr);//不需要为变量重新赋值，变量的内容就会变化
Console.WriteLine(arr2[0]);//1

string s = "hello";
string s2 = s.Replace("llo", "LLO");//需要用变量接受。原变量不会有任何变化
Console.WriteLine(s);
Console.WriteLine(s2);
```

# 可空引用类型

引用类型可以赋值为`null`值。这是一个非法的地址。访问他的任何内容会报错。
0长字符串和`null`的区别类似于，网购平台给别人刷单，  
0长字符串相当于给你发了一个空包裹，虽然包裹没有内容，但还是有配套的快递单之类的。  
`null`值字符串则是自始没有下单，所以连订单号都不存在。

可空引用类型是在类型后加上`?`，此举不会影响编译后的内容，  
只是告诉分析器这里的设计思路。如果和预期不同则会出现警告。

```csharp
string s4 = null;//给不带?的引用类型赋值null值会出现警告
string? s5 = null;//在类型后面加?，赋值可能null值就不会出现警告
Console.WriteLine(s4.Length);//对可能为null值的变量访问内容会出现警告
Console.WriteLine(s5.Length);

s4 = null!;//在值后面加!会告诉分析器，此处必不会为null
s5 = null!;
Console.WriteLine(s4.Length);//之后访问内容就不会出现警告
Console.WriteLine(s5.Length);
```

# 可空值类型

值类型是所有内容都储存在变量里的类型。

- 把值类型赋值给另一个变量，另一个变量的内容改变不会影响到原来的变量
- 值类型加上只读，里面的内容不会被改变
- 给值类型的内容赋值，这个内容必须是从变量上访问的  
  不能是表达式计算结果或方法返回值
- 默认比较里面的内容

```csharp
Vector3 vector = new Vector3();
(vector * 2).X = 6;//表达式的内容改写也无法获取到这个改写
```

值类型是直接储存内容的类型，因此不能使用`null`赋值。  
但如果一个值类型没有表示特殊情况的值，可以在类型后加`?`变成可空值类型。  

- 这会实际改变编译后的内容
- 可空值类型可以接受`null`值
- 可空值类型具有原类型所有运算符，若其中一个为`null`则计算结果为`null`
- 可空值类型必须通过`.Value`得到原类型的值后才能调用方法
    - 如果为`null`，则访问这个属性会报错

```csharp
int? i = null;
Console.WriteLine(i.HasValue);
Console.WriteLine(i * 2);
```

# 空传播

在访问一个东西的内容前（`.`或`[]`前)加上`?`，  
则这个东西是`null`的情况下不会继续访问内容，
表达式后续的所有内容访问都中断。  
表达式返回的类型会改为可空类型。

```csharp
int[]? arr3 = null;
int? i2 = arr3?[0];//但如果不是null，且索引超出范围，仍然会报错
i2 = arr3?.Length;
string? s = arr3?.Length.ToString();
s = i2?.ToString();//可空值类型用空传播访问内容时，直接视为原类型不需要.Value
```

## 空合并

对一个值后加上`??`，会在左侧为`null`时，改为用右侧的默认值进行替代。

```csharp
s ??= "";//如果为null，则赋值为
Console.WriteLine(arr3?.Length ?? 0);
Console.WriteLine((arr3?.Length).GetValueOrDefault(0));
//可空值类型会有GetValueOrDefault方法，和??效果一样
```